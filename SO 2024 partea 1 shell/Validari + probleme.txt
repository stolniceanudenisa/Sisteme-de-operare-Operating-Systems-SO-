 
Username: sdar2590
Password: ZTM3Nz^iYTc3






while read line ; do

done < $1 # $1 este input pentru read din while


-type f -name "*.txt"

grep -E -i -o ana file.txt | wc -l







nr de cate ori un cuvant se gaseste in fisier

if [ `expr $# % 2` -eq 1 ]; then
	echo ne trebuie pereche word-fisier
fi


while [ $# -ne 0 ]; do
	if [ -f $2 ]; then
		n=`grep =E -o -i $1 $2 | w -l` sau $""
	fi
	shift 2

done






touch temp.txt
for f in `find $dir -type f -name "*.c"`
do
	nrlinii=`grep -E -v -c "^[]*$"`
	s=`expr $s + $nrlinii`
	echo $f $nrlinii >> temp.txt
done

sort -k2 -n -r temp.txt
rm temp.txt
eccho $s nr total linii de cod c









9. Scriptul primeste perechi de cuvant fisier si afiseaza de cate ori apare cuvantul in fisierul corespunzator
./perechi.sh cuvan1 fisier1 cuvant2 fisier2 cuvant3 fisier3

#!/bin/bash

if [ `expr $# % 2` -eq 1 ]; then
    echo Ne trebuie prechi vuvant fisier
    exit 1
fi


touch temp.txt
while [ $# -ne 0 ]; do
    
    if [ -f $2 ]; then
        n=`grep -E -o -i "\<$1\>" $2 | wc -l`
        echo Cuvantul $1 apare de $n ori in fisierul $2.
        echo $n $2 >> temp.txt
    fi

    shift 2
done
sort -n -r temp.txt
rm temp.txt



-ge
-gt
-g than
-lt
-le

grep
cautare cuvant in fisier \banana\                  grep -q "\<$word\>" "$file"
cautare cuvant ana..in anastasia sa l gaseasca     grep -q "$word" "$file"


occurrences=$(grep -o -w -c "$word" "$fis")
occurrences=$(grep -o -E "\b$word\b" "$fis" | wc -l)


d="$1"
file="$2"
count=$(grep -o -w -c "$word" "$file")



word1="$1"
word2="$2"
file="$3"

count=$(grep -o -w -E "$word1|$word2" "$file" | grep -c "$word1.*$word2\|$word2.*$word1")






grep-E-v "[a-zA-Z0-9]" file  orice fara litere si numere


sed-E 's/([0-9]+)/\1\1/' file
“This 1234 is a number” will become “This 12341234 is a number”
 line “56.34” will become “5656.3434”


 Delete all characters after the last whitespace from each line from a file
sed-E "s/ [^ ]*$/ /" fil

 sed-E "s/\<[a-z]+\>//" file : Remove the first word containing only lowercase letters from each line of a file

sed-E "s/^([^:]*):([^:]*):([^:]*):/\1:\3:\2:/" /etc/passwd  swap field 3 cu field 2

 
Print all lines that contain at most 5 vowels, not necessarily consecutive, situated
 between 2 ^ signs 
grep-E "\^([^aeiou]*[aeiou][^aeiou]*){0,5}\^" file





---------------------------------------------- TESTEEEEEEEEEEEEEEEEE

1. argumente: 1 cuvant si oricate nume de fisiere. se valideaza cuvantul(doar litere), fisierele(se ignora cele nevalide) si nr minim de argumente (minim 2 - 1 cuvant si un fisier minim)

pt fisierele CE NU contin cuvantul, se adauga acel cuvant pe fiecare linise din fisier, dupa primul cuvant care incepe cu o vocala (se va face pentru fiecare fisier copie cu noul continut)

creati fisiere de test relevante

#!/bin/bash


if [ "$#" -lt 2 ]; then
        echo "ne trebuie un word si cel putin un fisier">&2
        exit 1
fi


word=$1
if ! [[ $word =~ ^[a-zA-z]+$ ]]; then
        echo "$1 nu este cuvant cuvant">&2
        exit 1
fi

shift

for file in $@; do
        if ! [ -f $file ]; then
                echo "$file trebuie sa fie un fisier valid">&2
                continue
        fi

        if grep -q "$word" "$file"; then      if tail -n 15 "$file" | grep -q "$word" "$file"; then

                echo "$file deja contine cuvantul '$word' ">&2
                continue
        fi


        touch "$file.bak"
        cp "$file" "$file.bak"


 	sed -i -E "s/\b([aeiouAEIOU][[:alnum:]]*)\b/\1 $word/" "$file"



        #sed -i -E '/\b[aeiouAEIOU]\b/{n;s/^/BRAVO\n/;}' "$file"
        #sed -i -E "s/\b([aeiouAEIOU][[:alpha:]]*)\b/\1 $word/" "$file"
        #sed -i -E "s/^([aeiouAEIOU])/\1 $word/" "$file"
	#sed -i -E "/\b[aeiouAEIOU][[:alpha:]]*\b/{n;s/^/$word\n/;}" "$file"
        #sed -i -E "s/(\b[aeiouAEIOU][[:alpha:]]*\b)/$word \1/" "$file"

echo "s-a efectuat scrierea in fisier"

done




 if tail -n 15 "$file" | grep -q "$word" "$file"; then
                echo "$file contine cuvantul '$word' ">&2
                ((count++))
        fi





2. word + oricate fisiere. 
aflati cate fisiere contin cuvantul dat introdus in ultimele 15 randuri ale fisierului si sa afiseze acel numar, alaturi de numele la fiecare fisier care contine cuvantul



aflati cate fisiere contin cuvantul dat introdus in ultimele 15 randuri ale fisierului si sa scrie acel numar in fisierul sol.txt


#!/bin/bash


if [ "$#" -lt 2 ]; then
        echo "ne trebuie un word si cel putin un fisier">&2
        exit 1
fi


word=$1
if ! [[ $word =~ ^[a-zA-z]+$ ]]; then
        echo "$1 nu este cuvant cuvant">&2
        exit 1
fi


shift

count=0

for file in $@; do
        if ! [ -f $file ]; then
                echo "$file trebuie sa fie un fisier valid">&2
                continue
        fi

        if tail -n 15 "$file" | grep -q "\<$word\>"; then
                echo "$file contine cuvantul '$word' ">&2
                ((count++))
        fi

done

echo "nr total: $count" > sol.txt

./t2.sh ana cuv1.txt cuv2.txt > sol.txt








3) nr N, nume de fisiere oricate
   validare N nr natural


script ul trebuie sa afle cate fisiere contin maxim N linii goale si sa scrie numele fisierelor si numarului lor de linii goale in sol2.txt

#!/bin/bash


if [ "$#" -lt 2 ]; then
        echo "ne trebuie un word si cel putin un fisier">&2
        exit 1
fi


N=$1
if ! [[ $N =~ ^[1-9][0-9]*$ ]]; then
        echo "$N nu este numar natural">&2
        exit 1
fi


shift


count=0
for file in $@; do
        if ! [ -f $file ]; then
                echo "$file trebuie sa fie un fisier valid">&2
                continue
        fi

        countliniigoale=$(grep -c '^$' "$file")

        if [ "$countliniigoale" -le "$N" ]; then
                echo "fisier: $file" > sol.txt
                echo "nr linii goale: $countliniigoale"
                ((count++))
        fi

done

echo "nr total fisiere: $count" > sol.txt


sed -i '/^$/d' "$file" 




4) word + oricate nume de fisiere
scriptul afla cate fisiere contin cuvantul dat in primele 10 randuri ale fisierului si sa scrie in sol.txt


if head -n 10 "$file" | grep -q "\<$word\>"; then
                echo "$file contine cuvantul '$word' ">&2
                ((count++))
        fi




5)

#!/bin/bash

if [ $# -lt 1 ]; then
        echo "Parametrii insuficienti"
        exit 1
fi

if [ "$(($# % 2))" -eq 0 ]; then
        echo "Nu ai nr de parametrii pari"
        exit 1
fi
number=$1

if [[ ! $1 =~ ^[0-9]+$ ]]; then
        echo "N nu e numar $number"
        exit 1
fi

shift

while [ $# -ge 2 ]; do
        count=0
        file=$1
        word=$2
        if [ -f "$file" ]; then
                count=$(grep -Eo "\<$word\>" "$file" | wc -l)
                if [ $count -ge $number ]; then
                        cp "$file" "$file.copie"
                        sed -i "/$word/d" "$file.copie"
                else
                        echo "Nu ai destule aparitii"
                fi
        else
                echo "Nu e file"
        fi
        shift 2
done



sau

for (( i = 1; i <= $#; i+=2 )); do
        count=0
        file=${!i}
        word=${!((i+1))}
        if [ -f "$file" ]; then
                count=$(grep -Eo "\<$word\>" "$file" | wc -l)
                if [ $count -ge $number ]; then
                        cp "$file" "$file.copie"
                        sed -i "/$word/d" "$file.copie"
                else
                        echo "Nu ai destule aparitii"
                fi
        else
                echo "Nu e file"
        fi
done



6) cuvant C si perechi de forma fisier numar. validare numere, fisierele si nr de argumente

script verifica daca fisierele contin cuvantul C de un numar de ori egal cu numarul pereche si in caz contrar scrie in SOL.TXT numele fisierului si numarul de aparitii al cuvantului, pe o linie separata pentru fiecare fisier

exemplu rulare ./script.sh cuvant fis1.txt 2 fis2.txt 5 fis3.txt 0


cu perechi nu merge bine NU MERGE BINEEEEEEEEEEEEEEEEEEEEEEEEE

#!/bin/bash

if [ $# -lt 3 ]; then
    echo "Invalid parameters" >&2
    
    exit 1
fi

word="$1"
if ! [[ "$word" =~ ^[a-zA-Z]+$ ]]; then
    echo "$word is not a valid word" >&2
    exit 1
fi

shift
while [ $# -ge 2 ]; do
    fis="$1"
    if ! [ -f "$fis" ]; then
        echo "$fis is not a valid file" >&2
        shift 1
        continue
    fi

    count="$2"
    if ! [[ "$count" =~ ^[0-9]+$ ]]; then
        echo "$count is not a valid number" >&2
        shift 1
        continue
    fi

    occurrences=$(grep -o -w -c "$word" "$fis")

    if [ "$occurrences" -ne "$count" ]; then
        echo "$fis: $occurrences"
    fi

    shift 2
done

-------------

fara perechi

#!/bin/bash

if [ $# -lt 3 ]; then
    echo "Insufficient parameters" >&2
    exit 1
fi

word="$1"
if ! [[ "$word" =~ ^[a-zA-Z]+$ ]]; then
    echo "$word is not a valid word" >&2
    exit 1
fi

fis="$2"
if ! [ -f "$fis" ]; then
    echo "$fis is not a valid file" >&2
    exit 1
fi

count="$3"
if ! [[ "$count" =~ ^[0-9]+$ ]]; then
    echo "$count is not a valid number" >&2
    exit 1
fi

occurrences=$(grep -o -w -c "$word" "$fis")

if [ "$occurrences" -ne "$count" ]; then
    echo "$fis: $occurrences" > sol3.txt
fi





7) perechi de forma fisier - director. validare fisiere directoare si nr de argumente

script ul verifica cate din directoare contin fisierul pereche, verificand si subdirectoarele acestuia, apoi scrie in fisier pentru fiecare pereche pe o linie separata.
Fisierul F apare de N ori in directorul D

rulare ./script.sh fis1.txt director1 fis2.txt director2 fis3.txt director3

#!/bin/bash

if [ $# -lt 2 ]; then
        echo "param insuficienti">&2
        exit 1
fi

if [ "$(($# % 2))" -ne 0 ]; then
    echo "parametri trebuie sa fie in perechi" >&2
    exit 1
fi

while [ $# -ge 2 ]; do
        fis=$1
        if ! [ -f "$fis" ]; then
                echo "$fis trebuie sa fie fisier" >&2
                shift 2
                continue
        fi

        dir=$2
        if ! [ -d "$dir" ]; then
                echo "$dir trebuie sa fie director" >&2
                shift 2
                continue
        fi
        count=$(find "$dir" -type f -name "$(basename "$fis")" | wc -l)

    echo "$fis appears $count times in $dir"
    shift 2
done





8) primeste un numar N, si perechi de forma fisier-director. validare N numar natural, fisierele, directoarele si nr de argumente
scr verifica cate din drectoare contin fisierul pereche(inclusiv subdirectoarele lui) si verifca daca nr total de astfel de directoare e mai mare decat N, afisand un mesaj catre utilizator,

ASTA E BUN CU 3 ARG 1 SHIFT 2 PERECHI in continuare


creati fis + dir relevante

rulare ./script.sh 2 fis1.txt director1 fis2.txt director2 fis3.txt director3

#!/bin/bash

# Check if the number of parameters is sufficient
if [ $# -lt 3 ] || [ $(($# % 2)) -ne 1 ]; then
    echo "Invalid parameters" >&2
    echo "Usage: $0 <N> <file1> <directory1> [<file2> <directory2> [...]]" >&2
    exit 1
fi

# Check if the first parameter is a natural number
N="$1"
if ! [[ "$N" =~ ^[1-9]+$ ]]; then
    echo "$N is not a natural number" >&2
    exit 1
fi

shift  # Move past the N parameter

# Loop through pairs of file and directory
while [ $# -ge 2 ]; do
    fis="$1"
    dir="$2"

    # Validate if the file exists
    if ! [ -f "$fis" ]; then
        echo "$fis does not exist or is not a file" >&2
        shift 2
        continue
    fi

    # Validate if the directory exists
    if ! [ -d "$dir" ]; then
        echo "$dir does not exist or is not a directory" >&2
        shift 2
        continue
    fi

    # Count how many directories contain the file
    count=$(find "$dir" -type f -name "$(basename "$fis")" | wc -l)

    # Check if the count exceeds N
    if [ "$count" -ge "$N" ]; then
        echo "The file $fis appears in more than $N directories: de $count ori"
    fi

    shift 2
done



 


88) triplete de forma fiser cuvant numar ( F C N). validare nr, fisiere si nr de argumente DIVIZIBIL CU 3	[a-zA-Z]

pentru fiecare triplet se verifica daca fisierul F contine cuvantul C pe mai mult de N linii, in caz contrar se dubleaza fiecare aparitie a cuvantului C din fisier.

rulare ./script.sh fis1.txt cuv1 5 fis2.txt cuv2 7 fis3.txt cuv3 10


#!/bin/bash

if [ $(($# % 3)) -ne 0 ]; then
    echo "Invalid number of parameters. Parameters should be in triplets (F C N)." >&2
    exit 1
fi

while [ $# -ge 3 ]; do
    fis="$1"
    cuv="$2"
    num="$3"

    if ! [ -f "$fis" ]; then
        echo "$fis does not exist or is not a file" >&2
        shift 3
        continue
    fi

    if ! [[ "$cuv" =~ ^[a-zA-Z]+$ ]]; then
        echo "$cuv nu e cuvant" >&2
        shift 3
        continue
    fi


    if ! [[ "$num" =~ ^[1-9]+$ ]]; then
        echo "$num is not a valid positive integer" >&2
        shift 3
        continue
    fi

    lines_with_word=$(grep -i -c "$cuv" "$fis")
    if [ "$lines_with_word" -le "$num" ]; then
        sed -i "s/$cuv/$cuv $cuv/g" "$fis"
        echo "Doubled occurrences of '$cuv' in $fis"
    fi

    shift 3
done

--------

sauuuuuuu


lines_with_word=$(grep -i -c "$cuv" "$fis")
    if [ "$lines_with_word" -lt "$num" ]; then
        sed -i "/$cuv/a $cuv" "$fis"
        echo "Inserted '$cuv' in the next line after occurrences of '$cuv' in $fis"
    fi


--------------


9) fisier 2 cuvinte - INCERCARE FARA TRIPLET

primul cuvant sa se inlocuiasca cu cel de al doilea cuvant
#!/bin/bash

if [ $# -lt 3 ]; then
        echo "parametri insuficienti">&2
        exit 1
fi


fis=$1
if ! [ -f $fis ]; then
        echo "$ fis trebuie sa fie fisier">&2
        exit 1
fi

word1=$2
if ! [[ $word1 =~ ^[a-zA-Z]+$ ]]; then
        echo "$word1 trebuie sa fie word">&2
        exit 1
fi


word2=$3
if ! [[ $word2 =~ ^[a-zA-Z]+$ ]]; then
        echo "$word2 trebuie sa fie word">&2
        exit 1
fi


sed -i "s/\b$word1\b/$word2/g" "$fis"
sed -i "s/\b$(echo "$word1" | sed 's/[aeiouAEIOU]//g')\b/$(echo "$word2" | sed 's/[aeiouAEIOU]//g')/g" "$fis"

 


delete_vowels() {
    echo "$1" | sed 's/[aeiouAEIOU]//g'
}

sed -i "s/\b$(delete_vowels "$word1")\b/$(delete_vowels "$word2")/g" "$fis"



------------- cu triplete

#!/bin/bash

if [ $# -lt 3 ]; then
    echo "Insufficient parameters" >&2
    exit 1
fi

if [ "$(($# % 3))" -ne 0 ]; then
    echo "Parameters must be in triplets" >&2
    exit 1
fi

while [ $# -ge 3 ]; do
    fis="$1"
    if ! [ -f "$fis" ]; then
        echo "$fis must be a file" >&2
        shift 3
        continue
    fi

    word1="$2"
    if ! [[ $word1 =~ ^[a-zA-Z]+$ ]]; then
        echo "$word1 must be a word" >&2
        shift 3
        continue
    fi

    word2="$3"
    if ! [[ $word2 =~ ^[a-zA-Z]+$ ]]; then
        echo "$word2 must be a word" >&2
        shift 3
        continue
    fi

    # Perform the replacement with vowels deleted
    sed -i "s/\b$(echo "$word1" | sed 's/[aeiouAEIOU]//g')\b/$(echo "$word2" | sed 's/[aeiouAEIOU]//g')/g" "$fis"

    shift 3
done




-------

10) triplete f word word 
cate din linii contin si cuvantul 1 si cuvantul 2 > sol.txt nume fisier + nr linii

#!/bin/bash

if [ $# -lt 3 ]; then
    echo "parametri insuficienti" >&2
    exit 1
fi

if [ "$(($# % 3))" -ne 0 ]; then
    echo "trebuie sa avem tripleti" >&2
    exit 1
fi

while [ $# -ge 3 ]; do
    if ! [ -f "$1" ]; then
        echo "$1 is not a valid file" >&2
        shift 3
        continue
    fi

    if ! [[ "$2" =~ ^[a-zA-Z]+$ ]] || ! [[ "$3" =~ ^[a-zA-Z]+$ ]]; then
        echo "$2 or $3 is not a valid word" >&2
        shift 3
        continue
    fi

    count_word1=$(grep -o -w -c "$2" "$1")
    count_word2=$(grep -o -w -c "$3" "$1")
    count=0

    if [ "$count_word1" -gt 0 ] && [ "$count_word2" -gt 0 ]; then
        ((count++))
    fi

    if [ "$count" -gt 0 ]; then
        echo "$1: $count" > sol2.txt
    fi

    shift 3
done

----------------

#!/bin/bash
 # tipuri de validare numere
for n in $@
do
    if echo $n | grep -E -q "^-?[0-9]+\.?[0-9]*$"
    then
        echo $n este numar
    fi
    if [ $n -eq $n ] 2>/dev/null
    then
        echo $n este un numar intreg
    fi
    if [[ $n =~ ^-?[0-9]+\.?[0-9]*$ ]]
    then
        echo $n verificat cu [[ ]]
    fi
done



--------------------------




6.	Scrieti un program care primeste ca prim argument un nume de fisier apoi oricate cuvinte. Se cere sa se stearga toate aparitiile cuvintelor date ca parametrii din fisierul care este dat ca prim parametru al programului. 


#!/bin/bash

fisier=$1
if [ ! -f $fisier ]  # verificam ca primul parametru este fisier
then 
	echo $1” trebuie sa fie fisier”
	exit 1
fi

shift # mutam argumentele cu o pozitie spre stanga, pentru a sari peste numele fisierului
cp $fisier copie # facem o copie la fisier numita copie, pentru ca vom modifica continutul lui

for cuv in "$@";
do
	sed -i "s/$cuv//g" $fisier  #optiunea -i modifica permanent fisierul, stergand cuvintele
done





7.	Sa se calculeze numarul de vocale dintr-un fisier text dat ca parametru in linia de comanda.

#!/bin/bash

if [ ! -f $1 ]  # verificam ca primul parametru este fisier
then 
	echo $1” trebuie sa fie fisier”
	exit 1
fi

# cautam cu grep o vocala (-i  case insensitive, deci si litere mari si litere mici)
# cu -o afisam fiecare potrivire separate pe o linie (deci fiecare vocala gasita pe o linie)
# cu pipe continuam procesarea cu wc -l care Numara liniile gasite, pe care avem cate o vocala
nv=`grep -E -i -o “[aeiou]” $1 | wc -l` # in nv vom avea numarul rezultat

echo Numarul de vocale este $nv







------------------------------------------------

#!/bin/bash
# username nr u2 nr2 u3 nr3 u4 nr 4 .... => verifica daca username s-a logat de minim nr ori pt fiecare pereche
if [ `expr $# % 2` -eq 1 ]; then
        echo Ne trebuie perechi de argumente.
        exit 1
fi
 
while [ $# -gt 0 ]; do
        # $1 este username?
        if grep -E -q "$1" /etc/pseudopasswd; then
                #echo $1 este in sistem
                if [[ $2 =~ ^[0-9]+$ ]]; then
                        #echo $2 este numar
                        nrlogs=`last | grep -E -c "$1"`
                        if [ $nrlogs -gt $2 ]; then
                                echo "$1 s-a logat de $nrlogs ori, $nrlogs>=$2"
                        else
                                echo "$1 s-a logat de $nrlogs ori <$2, nu ii dam punct bonus."
                        fi
                else
                        echo $2 nu este numar valid.
                fi
        else
                echo $1 nu este un utilizator din sistem.
        fi
        shift 2
Done
------------------
#!/bin/bash
 
# par1 fisier, par2...+ litere mici; pt fiecare litera, facem un fisier -> cuvintele care incep cu litera
# ./pb2d.c fis.txt a b c    => a.txt cuvintele din fis.txt care incep cu a ; b.txt -> cuvintele care incep cu b
 
if [ $# -lt 2 ]; then
        echo Ne trebuie minim 2 argumente.
        exit 1
fi
 
fisier=$1
if [ ! -f $1 ]; then
        echo Primul arg trebuie sa fie fisier.
        exit 1
fi
 
shift
 
for lit in $@; do
        if [[ $lit =~ ^[a-z]$ ]]; then
                grep -E -i -o "\<$lit[a-z]*\>" $fisier > ${lit}.txt
        else
                echo $lit nu este o litera mica, se ignora.
        fi
done
Cauta un cuvant in fisier cu shell:
#!/bin/bash
 
while read line;
do
        for cuv in $line
        do
                echo $cuv
                if [ $cuv == $1 ]; then
                        echo GASIIIIIIt!
                fi
        done
 
done < copie.txt



For the users that have a username that starts with a consonant and are still logged in, write the username and login time, sorted in increasing order by the login time. 

 

Solutions 

1) 

who |  awk -F' ' '{print $1 " " $4}' | sort -k 2 | grep -E -i "^[aeiou]" -v 

2) 

who | awk '$1~/^[^aeiou]/{print $1, $4}' | sort -k 2 

3) 

who | awk '$1 ~ /^[^aeiou]/  {print "Username:", $1, $3, $4}' | sort -k 2 | sort -k 5 | sort -k 4 

4) 

script.awk 

{ 
     if ($1 ~ /^[^aeiouAEIOU]/ && $0 ~ /still logged in/) 
         print $1, $7 
 } sort –k2 

last | awk -f script.awk 

 

5) 

who | awk '{print $1, $4}' | sort -k 2 | grep '^[^aeiou]' 

 

 



------------------------------------------------------------

stergere cuvinte duplicate din fisiere

inlocuire un cuvant dat cu un alt cuvant in toate fisierele

vocale consoane

sed scriere dupa o linie cu o proprietate
 	    inainte de o linie cu o proprietate

grep primele 10 linii
     ultimele 15 linii


SO

fisierul passwd.fake cu continut asemanator cu /etc/passwd  
fisierul last.fake cu continut asemanator cu rezultatul comenzii last 



Validari
SCRIPT care verifica daca:
AFISATI mesaj la STDERR daca parametrul nu e valid
INSTRUCTIUNI  if, for, test [], echo


1) primul parametru dat este un numar

#!/bin/bash

if ! [[ $1 =~ ^[0-9]+$ ]]; then  
if ! [[ $1 =~ ^-?[0-9]+$ ]]; then
        echo "nu este numar" >&2
else
        echo "este numar"
fi
 
./1.sh banana > file.txt
 ./1.sh banana 2> file.txt
cat file.txt


? - o data sau deloc
+ - 1 sau mai multe ori 
* - zero sau mai multe ori


#!/bin/bash

nr=$1

if echo $nr | grep -E -q "^-?[0-9]+$"
then
        echo $nr este numar
        exit 0
else
        echo $nr nu este numar
        exit 1
fi


DACA STERG -q imi afiseaza $nr  de 2 ori
./1d.sh -12
-12
-12 este numar




2) primul parametru dat este un cuvant (format doar din litere)

#!/bin/bash

if ! [[ $1 =~ ^[a-zA-Z]+$ ]]; then
        echo "$1 nu este un cuvant" >&2

fi


3) primul parametru dat este un fisier

#!/bin/bash

fis=$1
if ! [[ -f $fis ]]; then
        echo "$fis nu este un fisier" >&2
fi



4) primul parametru dat este un director
#!/bin/bash

dir=$1
if ! [ -d $dir ]  sau  [ ! -d $dir ]
then
        echo "$dir nu este un director" >&2
        exit 1
fi



5) primul parametru e fisier, restul sunt cuvinte
DE REZOLVAT DACA DAM ARGUMENT GOL DUPA FILENAME

#!/bin/bash

fis=$1
if [ ! -f $fis ]; then
        echo "$fis nu este un fisier" >&2
        exit 1
fi

shift

if [ "$#" -eq 1 ]; then
    echo "Nu s-au furnizat cuvinte după numele fișierului."
    exit 1
fi


for param in $@; do
        if [[ -z "$param" ]]; then
                echo "argument gol nu e cuvant"
                exit 1

        elif [[ ! $param =~ ^[a-zA-Z]+$ ]]; then
                echo "$param nu e cuvant" >&2
                exit 1
        fi
done

echo "toti parametrii sunt cuvinte"





6) primul parametru e fisier, restul sunt numere

#!/bin/bash

fis=$1
if [ ! -f $fis ]; then
        echo "$fis nu este un fisier" >&2
        exit 1
fi

shift


for param in $@; do
        if [[ -z "$param" ]]; then
                echo "argument gol nu e numar"
                exit 1

        elif [[ ! $param =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
                echo "$param nu e numar" >&2
                exit 1
        fi
done

echo "toti parametrii sunt numere"







-z is a conditional expression used to check if a string is empty or has zero length. Specifically, it checks if the length of the string is zero.

Here's how it works:

[ -z "$string" ]: This expression evaluates to true if the variable string is empty or has a length of zero.



string=""
if [ -z "$string" ]; then
    echo "The string is empty."
else
    echo "The string is not empty."
fi




---------

PART 2 IMPORTANTE


cautare cuvant in fisier \banana\                  grep -q "\<$word\>" "$file"
cautare cuvant ana..in anastasia sa l gaseasca     grep -q "$word" "$file"


if [ $# -lt 2 ]; then
        echo "Parametrii insuficienti">&2
        exit 1
fi


if [ "$(($# % 2))" -ne 0 ]; then
    echo "parametri trebuie sa fie in perechi" >&2
    exit 1
fi

if [ $# -lt 3 ] || [ $(($# % 2)) -ne 1 ]; then   PB 8 BUNA
    echo "Invalid parameters" >&2
    echo "Usage: $0 <N> <file1> <directory1> [<file2> <directory2> [...]]" >&2
    exit 1
fi


while [ $# -ge 2 ]; do
        shift 2
done



if grep -q "$word" "$file"; then 
if grep -q "\<$word\>" "$file"; then 
if tail -n 15 "$file" | grep -q "\<$word\>" ; then
   head -n 10
	echo "$file contine cuvantul '$word' ">&2
                ((count++))
fi


count=$(find "$dir" -type f -name "$(basename "$fis")" | wc -l) - cate din directoare si subdir contin fis pereche

countliniigoale=$(grep -c '^$' "$file")
occurrences=$(grep -o -w -c "$word" "$fis")

    if [ "$occurrences" -ne "$count" ]; then
        echo "$fis: $occurrences"
    fi


count_word1=$(grep -o -w -c "$2" "$1")
    count_word2=$(grep -o -w -c "$3" "$1")
    count=0

    if [ "$count_word1" -gt 0 ] && [ "$count_word2" -gt 0 ]; then
        ((count++))
    fi

    if [ "$count" -gt 0 ]; then
        echo "$1: $count" > sol2.txt
    fi




sed -i -E "s/\b([aeiouAEIOU][[:alnum:]]*)\b/\1 $word/" "$file"
sed -i '/^$/d' "$file" 

touch "$file.copie"
cp "$file" "$file.copie"















 


  

+ unul/mai multe ori
* 0 sau mai multe ori
? o data sau deloc


stergere spatii de dinainte de cuvinte  
sed -E -i "s/^ //" laptopuri.txt

sed -i '/^$/d' laptopuri.txt

sed -i "/^$/d" laptopuri.txt


sed -i -r  's/un/1/g; s/doi/2/g; s/trei/3/g' $1

sed -i "/^$2,$3,/s/,[0-9]\+/,${4}/" "$1"

sed -E 's/[0-9]+//g' ex1.txt       --> substitute cifrele cu nimic

sed -E 's/[0-9]+//' ex1.txt      --- daca nu pun g imi ia doar prima aparitie unde apar cifre pe fiecare linie

grep -E -i “\<dan\>|\<ana\>” /etc/pseudopasswd

grep -E -i “^[aeiou][^:]:” /etc/pseudopasswd

grep -E -i -o “^[aeiou][^:]:” /etc/pseudopasswd

grep -E -i “nologin$” /etc/pseudopasswd


sed '2,5p' angajati.txt

sed '/Ion/,/Victor/p' angajati.txt

sed '/Tudor/d' angajati.txt

sed 's/Tudor/Tudorel/' angajati.txt

sed –n 's/Tudor/Tudorel/' angajati.txt

sed 's/19/18/g' angajati.txt

sed 's/1931/1932/gi' angajati.txt

sed -E 's/(Ion)el/\1ut/gi' angajati.txt

sed -E 's/[0-9][0-9]$/&\.5/' angajati.txt

sed '/Olga/,/Toma/s/$/**CONCEDIU**/' angajati.txt

sed -E “s/[0-9]/*/g” /etc/pseudopasswd

sed -E “s/[0-9]/*/” /etc/pseudopasswd

sed -E “s/[aeiou]/&&&/g” /etc/pseudopasswd

sed -E “s/[aeiou]/&&&/gi” /etc/pseudopasswd

sed -E “s/([aeiou])([aeiou])/\2\1/gi” /etc/pseudopasswd

sed -E “s/[^:]//gi” /etc/pseudopasswd


awk -F'[ :\t]' '{print $1, $2, $3}' angajati.txtawk '{print}' angajati.txt

awk '{print $0}' angajati.txt

- print all lines which contain the given pattern:

awk '/Tudor/' angajati.txt

awk '/Tudor/{print}' angajati.txt

awk '/Tudor/{print $0}' angajati.txt

- change the default input field separator:

awk -F: '{print $1}' /etc/passwd

awk -F: '{print NR, $1}' /etc/passwd


awk '$5 < 2000' angajati.txt

awk '$5 < 2000 {print}' angajati.txt

awk ' $5 == 1942 {print NR, $1}' angajati.txt

- using relational operators and regular expressions:

awk ' $1 ~ /Tudor/ {print}' angajati.txt

awk ' $1 !~ /Tudor/ {print}' angajati.txt


awk 'BEGIN{FS = ":"}' /etc/passwd

awk 'BEGIN{FS = ":"; OFS="\t"} {print $1, S2}' /etc/passwd

awk '/Ion/{cnt++}END{print "Ion apare de " cnt " ori."}' angajati.txt

awk 'END{print "Nr. angajati: " NR}' angajati.txt

awk 'BEGIN{total=0} {total++} END{print "Total: " total}' angajati.txt


awk '{print $0}' fulga.txt - fiecare linie

awk '{print $1}' fulga.txt - primul cuvant din fiecare linie

awk -F',' '{print $1}' fulga.txt - schimbam separatorul in virgula

FNR - renumeroteaza liniile
NR - liniile procesate

 awk  '/^a/ {print $1}' fulga.txt - primul cuvant incepe cu a
 awk -f file.awk fulga.txt - asa rulam



#!/bin/bash
echo '{for(i=1;i<NF;i++) if($i==$(i+1)) print NR, $i}' > filee.awk
awk -f filee.awk $1

--------------------

cat roua.awk
BEGIN {FS=","; OFS=";"}
$3>1899 {print $1,$3}


awk -f "roua.awk" flg asa rulam




awk -F, '{print $1}' flg
nano roua.awk
awk -f "roua.awk" flg


BEGIN {print "inceput"}
{print $1}
END {print "sfarsit"}


BEGIN {print "inceput"}
BEGIN {FS=","}
{print $1}
END {print "sfarsit"}


BEGIN {print "inceput"}
/^a/ {print $1}
END {print "sfarsit"}



BEGIN {FS=","}
{print $1, $4-$3}
END {print "sfarsit"}  nume + cati ani a dormit


sau 

BEGIN {FS=","}
{print $1, $NF-$(NF-1)}
END {print "sfarsit"}


an = anul fiec domn
BEGIN {FS=","}
{an=$4-$3; print an}
END {print "sfarsit"}


 
BEGIN {FS=","}
{an=$4-$3;
    if (max<an) {
        max=an;
        dom=$1;
    }
}
END {print dom,max}



OFS AFISARE
FS CIITIRE

BEGIN {FS=","; OFS=";"}
{an=$4-$3;
    if (max<an) {
        max=an;
        dom=$1;
    }
}
END {print dom,max}


cronologic dommnitori din sec 20s



BEGIN {FS=","; OFS=";"}
{an=$4-$3;
    if (max<an) {
        max=an;
        dom=$1;
    }
}
END {print dom,max}





ceva nu merge
BEGIN {FS=","; OFS=";"}
{aninceput=$3;
 ansfarsit=$4;
    if (aninceput>=1900 && ansfarsit<=2000) {


        domnitori[$1] = $3;
        print $1, $3"-"$4;

    }
}
END {
        asort(domnitori);
        for (domn in domnitori)
        {
                print dom, domnitori[dom];
        }
}






------------------------------------

BEGIN {FS=","; OFS=";"}
$3>1899 {print $1,$3}




awk -f "roua.awk" flg.txt | sort -t ";" -k 2
ferdinand I;1916
alexandru ioan cuza;1920
joseph stalin;1921
alexandru cel bun;1930
adolf hitler;1933
nicolae ceausescu;1965
fulga;2013











find | grep -E "\.txt$"



if grep -E -q "\<$cuvant\>" $fisier; then
	echo "$fisier"
fi



n=0
n=`expr $n + 1`
echo $n


SAU


touch rez.tmp
echo $fisier >> rez.tmp
cat rez.tmp
l=`cat rez.tmp | wc -l`
$l = nr total de fisiere
rm rez.tmp

wc -l fis.txt


#!/bin/bash 
list=`find | grep -E "\.txt$"`
for f in $list; do
	cat $f
done


./display.sh .practice
              practice
              pwd  /home/../practice


find -type f -name "*.txt"
grep -E ".*" exercitii.txt


list=`find -type f -name "*.txt"`
for f in $list; do
	grep -E ".*" $f
done




explicatie

# read line citeste din fisierul "done < $1"
while read line; do
	# cut -d  "separator", -f 4 (de ex cuv1,cuv2,cuv3,cuv4 => cuv4)
	capacitate_cilindrica=$(echo $line | cut -d, -f 4)


no_models=$(grep "^$2," "$1" | cut -d ',' -f 2 | sort | uniq | wc -l)




#Sa se adauge in fata fiecarei litere mici cuvantul indicat ca
#prim parametru. Fisierele tratate sunt ceilalti parametrii din
#linia de comanda.
first=$1
for file in "${@:2}"
do
sed -r 's/[a-z]/'$first' &/g' $file	
done





suma=0

for nr in "$@"; do
    if [ "$nr" -eq "$nr" ]; then
        suma=$((suma + nr))
    else
        echo "parametru invalid">&2
        exit 1
    fi
done
echo "$suma"




#!/bin/sh

# directorul cu fișierele de transport
dir=$1

# verificam daca exista doar un parametru
if [ $# -ne 1 ]; then
    echo "parametru invalid">&2
    exit 1
# verificam daca parametrul dat este un director
elif [ ! -d $dir ]; then
        echo "parametru invalid">&2
        exit 1
fi

# parcurgem fiecare fișier
for file in $dir/*; do
    # verificam daca fisierul este text
    if [ -f $file ]; then
        # verificăm dacă primul rând conține "IN"
        first_line=$(head -n 1 "$file")
        if [ "$first_line" = "IN" ]; then
        # afișăm numele fișierului
            echo "$(basename "$file")"
        fi
    fi
done | sort










lab5 pr10
#!/bin/sh

dir=$1

# verificam daca primul parametru dat este un director
if [ ! -d $dir ]; then
    exit 1
fi

# verificam tot ce este in director
for file in "$dir"/*; do
    # verificam sa fie fisier
    if [ -f "$file" ]; then
        # salvam suma produselor din fisier
        total=$(awk -F ',' 'NR>1 {sum += $2} END {print sum}' "$file")
        # afisam numele fisierului + suma totala
        echo "$(basename "$file") $total"
    fi
done | sort









#!/bin/bash

# [ ! -f parametru ] - verifica daca fisierul nu exista
# [ ! -d parametru ] - verifica daca directorul nu exista 
# >&2 trimite eroarea in stderr
if [ ! -f "$1" ]; then
	echo "parametru invalid" >&2
	exit 0
fi

# read line citeste din fisierul "done < $1"
while read line; do
	# cut -d  "separator", -f 4 (de ex cuv1,cuv2,cuv3,cuv4 => cuv4)
	capacitate_cilindrica=$(echo $line | cut -d, -f 4)
	# cut -d "separator", -f 3 (de ex cuv1,cuv2,cuv3,cuv4 => cuv4)
	cai_putere=$(echo $line | cut -d, -f 3)
	# let permite calculul si atribuirea valorii unei expresii matematice la o variabila
	let raport=$capacitate_cilindrica/$cai_putere
	# afisam rezultatul
	echo $raport
# < $1 arata din ce fisier se citeste (fisierul dat in parametrul 1)
done < $1









GREP DANIEL BOTA

1. Afisati toate liniile care contin sirul 'Tudor'.
grep (-E) (-i) 'Tudor' angajati.txt   sau "Tudor"

grep "ceva" angajati.txt  ---> cauta cuvantul ceva in fisier

grep "^S" angajati.txt ---> liniile care incep cu litera S

grep "2$" angajati.txt ---> liniile care se termina cu cifra 2

grep '[0-9]' angajati.txt ---> linii ce contin cifre

grep '[^a-z0-9]' angajati.txt

grep '\s' angajati.txt ---> linii ce contin space

grep '\a' angajati.txt---> linii ce contin litera a

grep '[aeiou]' angajati.txt


Search for lines containing a specific pattern followed by any character:

grep "pattern." file.txt
grep 'a.' angajati.txt


Search for lines containing a specific pattern followed by zero or more occurrences of a character:

grep "pattern*" file.txt
grep 'R*' angajati.txt


Search for lines containing a specific pattern followed by one or more occurrences of a character:

grep "pattern+" file.txt



2. Afisati toti angajatii care au numele 'Tudor'.
grep "^Tudor" angajati.txt


3. Afisati toate liniile care contin sirul '1942'.
grep "1942" angajati.txt


4. Afisati toti angajatii al caror salariul este 1942.
grep "1942$" angajati.txt ----> salariul e la final de rand


5. Afisati toti angajatii al caror nume de familie incepe cu litera A.
grep "^A" angajati.txt --asta e de fapt prenume
grep '^[^ ]* A' angajati.txt -- nume de familie
awk '$2 ~ /^A/' angajati.txt


6. Afisati toti angajatii al caror numar de telefon incepe cu 0741.
grep '^. 0741' angajati.txt
awk '$6 ~ /^0741/' angajati.txt

7. Afisati toti angajatii nascuti in luna martie. 

grep '/3/' angajati.txt
awk -F ':' '$3 ~ /3\// {print}' angajati.txt
grep '10/' angajati.txt  - nascuti in ziua 10
grep '/1931' angajati.txt - nascuti in anul 1931


8. Afisati toti angajatii care locuiesc in Floresti.
grep 'Floresti' angajati.txt
awk -F ':' '$5 ~ /Floresti/ {print}' angajati.txt   --- nu merge


9. Afisati toti angajatii care nu locuiesc in Floresti.
awk -F ':' '$5 !~ /Floresti/ {print}' angajati.txt



10. Afisati toti angajatii care nu locuiesc in Floresti sau in Cluj-Napoca.
grep -v 'Floresti' angajati.txt   ---->  -v invers match

11. Afisati toate liniile care contin o majuscula urmata de 4 litere mici, un spatiu si o majuscula.
grep '[A-Z][a-z]\{4\} [A-Z]' angajati.txt
grep '[[:upper:]][[:lower:]]\{4\} [[:upper:]]' angajati.txt



12. Afisati toate localitatile de domiciliu care incep cu litera F sau S.
grep -o '\b[F|S][a-zA-Z]*' angajati.txt | sort | uniq    -- fara duplicate
\b: Matches a word boundary to ensure that only complete words are matched.

Floresti
Florilor
Silviu
Sindicatelor
Someseni
Sportului
Stejarului
Stela

grep -o '[F|S][a-zA-Z]*' angajati.txt  -o ia doar cuvintele Floresti... 
-o: Outputs only the matched parts of the lines.

grep '[F|S][a-zA-Z]*' angajati.txt - gaseste bine dar scrie linia cu totul

 grep -o -E '\b[F|S][a-zA-Z]+' angajati.txt  ---> ne trb -E pt +

daca nu pun + ne ia doar Fl So Fl St.... 


13. Afisati toate salariile care au 5 cifre.
grep -E -o '[0-9]{5}' angajati.txt
12345
65432
12453
23564
16245
48576
37005
25836
14725
12378
45216
45871
56321
85236
78945
32150
36914
98712
45698

grep -E -o '\b[0-9]{5}\b' angajati.txt
37005
32150


14. Afisati doar primul salariu care are 5 cifre.
grep -E -o -m 1 '[0-9]{5}' angajati.txt
12345


-m 1 se opreste la primul


15. Afisati toate salariile care au 5 cifre si 2 linii inainte/dupa. ????????


16. Afisati numarul de angajati care locuiesc in Cluj-Napoca.
 
grep -c 'Cluj-Napoca' angajati.txt       14

awk '/Cluj-Napoca/ {count++} END {print count}' angajati.txt     14




Let's say we want to print the employees who were born before 1965 from the angajati2.txt file. We can use a regular expression pattern to match the birth date and then check if it is before 1965. Here's how we can do it:
 
awk -F'[: ,]' '$4 < 1965 {print $1, $2, $3}' angajati2.txt
Explanation:

-F'[: ,]': This sets the field separator to either a colon :, comma ,, or space ``. This allows us to split the input lines based on these characters.
'$4 < 1965 {print $1, $2, $3}': This is the pattern-action pair. It matches lines where the fourth field (the birth year) is less than 1965, and if the condition is met, it prints the first three fields (the employee's name).






Begin Pattern (BEGIN):

 
awk 'BEGIN{print "Start processing..."} {print $0}' file.txt
This command will print "Start processing..." before processing any input from the file file.txt, and then it will print each line of the file.


Range Patterns:

 
awk '/Ionel/,/Alexandru/ {print $0}' angajati2.txt
This command will print all lines from the line containing "Ionel" to the line containing "Alexandru" in the file angajati2.txt.

Regular Expression Patterns:
 
awk '/Cluj-Napoca/ {print $0}' angajati2.txt
This command will print all lines containing the text "Cluj-Napoca" in the file angajati2.txt.

User-defined Patterns:
 
awk '{if ($6 > 3000) print $0}' angajati2.txt
This command will print all lines from the file angajati2.txt where the salary (the sixth field) is greater than 3000.


-------------------------------


SED DANIEL BOTA

1. Afisati continutul intregului fisier.

sed 's/^//' sedangajati.txt
Ion Popescu 10/3/1961 0740-123456 3500
Vasile Georgescu 5/10/1942 0722-654321 2850
Alexandru Ionescu 3/7/1971 0721-124536 3875
Tudor Alexandrescu 2/5/1963 0742-235641 2355
Victor Baciu 25/9/1968 0723-162453 4560
Horatiu Vasilescu 23/4/1965 0741-485769 37005
Adrian Pintea 11/8/1957 0742-258369 1942
Mircea Diaconu 6/11/1946 0744-147258 2565
Ovidiu Moldovan 17/1/1942 0722-123789 1968
Puiu Calinescu 21/6/1920 0723-452163 1971
Olga Tudorache 24/1/1932 0744-458712 1942
Stela Enache 28/2/1952 0745-563214 1946
Radu Beligan 8/4/1949 0744-852369 1957
Octavian Cotescu 17/12/1954 0745-789456 32150
Silviu Achim 19/10/1936 0726-369147 1932
Toma Voicu 27/5/1948 0740-987125 1949
Ilarion Ciobanu 4/7/1931 0728-456987 1946
Gheorghe Dinica 30/2/1934 0740-256314 1963
Liviu Ciulei 26/9/1947 0741-785469 1920
Victor Rebengiuc 31/3/1931 0723-254136 1954
Vlad Nicolaescu 13/3/1965 0745-741289 1949


2. Afisati liniile de la 5 pana la 10.

sed -n '5,10p' sedangajati.txt
Victor Baciu 25/9/1968 0723-162453 4560
Horatiu Vasilescu 23/4/1965 0741-485769 37005
Adrian Pintea 11/8/1957 0742-258369 1942
Mircea Diaconu 6/11/1946 0744-147258 2565
Ovidiu Moldovan 17/1/1942 0722-123789 1968
Puiu Calinescu 21/6/1920 0723-452163 1971



3. Afisati liniile de la 8 pana la ultima.

sed -n '8,$p' sedangajati.txt
Mircea Diaconu 6/11/1946 0744-147258 2565
Ovidiu Moldovan 17/1/1942 0722-123789 1968
...
Vlad Nicolaescu 13/3/1965 0745-741289 1949


 
4. Afisati liniile care contin sirul 'Tudor'.   Tudor -> Tudorache
 sed -n '/Tudor/p' sedangajati.txt                    /p ----> PRINT
Tudor Alexandrescu 2/5/1963 0742-235641 2355
Olga Tudorache 24/1/1932 0744-458712 1942



5. Afisati liniile care contin cuvantul 'Tudor'.
sed -n '/\bTudor\b/p' sedangajati.txt



6. Stergeti liniile de la 1 pana la 3.
sed '1,3d' sedangajati.txt


7. Stergeti liniile care contin cuvantul Popescu.
sed '/Popescu/d' sedangajati.txt


8. Stergeti liniile de la Ion la Tudor.
sed '/Ion/,/Tudor/d' sedangajati.txt


9. Stergeti ultima linie din fisier.
sed '$d' sedangajati.txt


10. Stergeti toate liniile care sunt goale.
 sed '/^$/d' sedangajati.txt                   ^$ = empty
 

11. Inlocuiti cuvantul Olga cu **Olga**.
sed 's/Olga/**Olga**/g' sedangajati.txt
nu merge cu y -- face altceva  sed 'y/Olga/OOOO/' sedangajati.txt


12. Inlocuiti toate aparitiile numarului 19 cu numarul 18.
sed 's/19/18/g' sedangajati.txt 

s/old/new/g is used to substitute all occurrences of "old" with "new".


13. Creati o copie de rezerva a fisierului de date (angajati.bak).
cp sedangajati.txt angajati.bak


14. Adaugati o linie noua dupa a 3-a linie din fisier.

sed '3a\
Linie noua adaugata.' sedangajati.txt
3a\ adds the text after the 3rd line.


inainte de a 3-a 
sed '2i\Text to add before the 3rd line' sedangajati.txt
2 specifies the line number before which the text will be inserted.
i\ is the sed command to insert text before the specified line.


between lines
sed '2,4i\Text to add between the 2nd and 4th lines' sedangajati.txts
2,4 specifies a range of lines from the 2nd to the 4th line.
i\ is the sed command to insert text before the specified range of lines.



15. Adaugati o linie noua dupa numele Adrian.

sed '/Adrian/a\
Linie noua adaugata.' sedangajati.txt


 

16. Adaugati textul 'TERMINAT' la sfarsitul fisierului.
sed -e '$a\TERMINAT' sedangajati.txt

-e: Specifică o expresie de editare.
'$a\TERMINAT': $ reprezintă ultima linie, a indică adăugarea textului, iar \TERMINAT este textul ce va fi adăugat.

17. Inlocuiti textul de pe linia 2 cu textul 'SALARIAT PENSIONAT'.

sed '2s/.*/SALARIAT PENSIONAT/' sedangajati.txt


18. Inserati la inceputul fisierului textul 'DATE DESPRE PERSONAL'.
sed '1i\DATE DESPRE PERSONAL' sedangajati.txt



19. Inlocuiti spatiile cu tab-uri si afisati rezultatul cu sed.

sed 's/ /\t/g' sedangajati.txt      / / = space -> toate spatiile vor fi inlocuite



20. Opriti executia programului dupa afisarea celei de a 5-a linii.

sed '5q' sedangajati.txt


21. Inserati dupa a 3-a linie un text citit dintr-un fisier.
sed '3r insert.txt' sedangajati.txt

r indică citirea și inserarea textului dintr-un fișier extern



22. Inserati pe a 5-a linie data si ora curenta.   NUJJJJJJJJJJJJJJJ


23. Scrieti un script care:
	a. Insereaza deasupra primei linii textul 'DATE DESPRE PERSONAL'
	b. Sterge salariile care se termina cu 49
	c. Tipareste continutul fisierului cu numele angajatului pe prima pozitie si prenumele pe a doua pozitie
	d. Adauga la sfarsitul fisierului textul 'TERMINAT'



-------------------------------

AWK DANIEL BOTA

1. Afisati continutul intregului fisier.
awk '{print}' awkangajati.txt
awk '{print $0}' awkangajati.txt


2. Afisati continutul intregului fisier prefixand fiecare linie cu numarul acesteia.
awk '{print NR, $0}' awkangajati.txt


3. Afisati continutul intregului fisier prefixand fiecare linie cu numarul campurilor acesteia.
awk '{print NF, $0}' awkangajati.txt


4. Afisati doar numele, prenumele angajatului si numarul de telefon.
awk '{print $2, $1, $4}' awkangajati.txt

awk '{print $2, "\t" $1, "\t" $4}' awkangajati.txt



5. Afisati angajatii al caror nume incepe cu litera T.

awk '/^T/' awkangajati.txt
awk '/^T/{print}' awkangajati.txt

6. Afisati numele si prenumele angajatilor nascuti in luna martie.

awk '/\/03\//{print $2, $1}' awkangajati.txt


7. Afisati angajatii al caror salariu este 1969.

awk '$5 == 1942 {print}' awkangajati.txt

8. Afisati angajatii al caror salariu este mic decat 2000.
awk '$5 < 2000 {print}' awkangajati.txt

9. Afisati liniile care contin mai mult de 42 caractere.
awk 'length($0) > 42 {print NR, $0}' awkangajati.txt


10. Calculati si afisati numarul total de angajati.
awk 'BEGIN {total = 0} {total++} END {print "Numarul total de angajati: ", total}' awkangajati.txt


11. Calculati si afisati suma necesara pentru plata salariilor pe o luna.
awk 'BEGIN {suma = 0} {suma += $5} END {print "Suma necesara: ", suma}' awkangajati.txt 


12. Afisati numarul de argumente furnizate in linia de comanda.
awk 'BEGIN {print "Numarul de argumente: ", ARGC}' unu doi trei patru


13. Afisati argumentele furnizate in linia de comanda.
awk -f script_1 unu doi trei patru


14. Afisati numele fisierului furnizat in linia de comanda

awk 'END {print "Numele fisierului: ", FILENAME}' awkangajati.txt


15. Scrieti un script care:
	a. Afiseaza un cap de tabel (Nume Prenume Data nasterii Telefon Salariu);
	b. Tipareste tabulat fiecare angajat
	c. Afiseaza la sfarsit numarul total de angajati

----------------------------------------------------------
Dump awk variables

awk --dump-variables ''
cat awkvars.out

Profile option

awk --profile 'BEGIN{printf"---|Header|--\n"} {print} 
END{printf"---|Footer|---\n"}' angajati.txt > /dev/null 
cat awkprof.out






-------------------








denisa@DESKTOP-K5RTQGH:~/pregatireshell$ ./test.sh
This is a regular message
This is an error message
denisa@DESKTOP-K5RTQGH:~/pregatireshell$ ./test.sh > output.txt
This is an error message
denisa@DESKTOP-K5RTQGH:~/pregatireshell$ ./test.sh > output.txt 2>&1
denisa@DESKTOP-K5RTQGH:~/pregatireshell$ ./test.sh > output.txt 2>&1
denisa@DESKTOP-K5RTQGH:~/pregatireshell$ cat output.txt
This is a regular message
This is an error message
denisa@DESKTOP-K5RTQGH:~/pregatireshell$ rm output.txt
denisa@DESKTOP-K5RTQGH:~/pregatireshell$ ./test.sh > output.txt
This is an error message
denisa@DESKTOP-K5RTQGH:~/pregatireshell$ cat output.txt
This is a regular message
denisa@DESKTOP-K5RTQGH:~/pregatireshell$







PB 2 LAB 6

Problema  2:
Se da un fisier text prin parametru. Sa se creeze un director cu numele "dictionar" care sa contina 26 de fisiere dictionar, astfel: primul fisier avand numele "A" contine, ordonate alfabetic, cate unul pe linie,
toate cuvintele din fisierul text care incep cu litera 'a' (sau A mare), al doilea cu litera ’B’ s.a.m.d.. Nu se va afisa nimic la iesirea standard. Toate cele 26 de fisiere dictionar vor fi create chiar daca acesta vor fi goale.


-i ignore case letters

#!/bin/bash

if [ ! -f "$1" ]
then
        echo "trebuie sa fie fisier" >&2
        exit 1
fi

mkdir -p dictionarlitere

for i in {A..Z}; do
        grep -i "^$i" "$1" | sort -u > "dictionarlitere/$i"
done









PB 3 LAB 6
In fisierul cu "studenti.csv" se afla numele studentilor ordonati in functie de media notelor primite la sesiunea din iarna. Dandu-se pentru fiecare student notele la cele 5 examene din vara (in fisierul ’notevara.csv’) sa se actualizeze fisierul initial astfel incat sa contina clasamentul real pe anul universitar respectiv.
Pe fiecare linie din fisierul "studenti.csv" se afla informatii in urmatorul format: pentru fiecare student exista cate o linie care contine numele studentului si nota acestuia separate prin caracterul virgula. exemplu: popescu ion,10
Pe fiecare linie din fisierul "notevara.csv" se afla informatii in urmatorul format: pentru fiecare student exista cate o linie care contine numele studentului si cele 5 note separate prin caracterul virgula. exemplu: popescu ion,10,8,9,10,9
La iesirea standard nu se va afisa nimic.



studenti.csv
ana,10
maria,10
carmen,9
andrei,8
alex,7

notevara.csv
ana,19,8,9,7,6
maria,10,10,10,10,10
andrei,9,9,9,9,9
alex,8,7,6,8,9


 ./l6p3.sh

#!/bin/bash

awk -f script.awk notevara.csv



script.awk
BEGIN {FS=",";OFS=","}
{
        print $1, $2 + $3 + $4 + $5 + $6 / 5
}




PB 5 LAB 6

Se dau ca parametrii doua nume de directoare. Sa se mute ramura desemnata de cel de-al doilea director ca subramura
a primului, adaugand extensia .unu la fiecare fisier. Scriptul nu va afisa nimic la iesirea standard.


director_sursă/
    - fișier1.txt
    - subdirector/
        - fișier2.txt
director_destinație/

mv director_sursă director_destinație


-->  director_destinație/
    - director_sursă/
        - fișier1.txt
        - subdirector/
            - fișier2.txt

Directorul director_sursă a fost mutat în director_destinație și apoi a fost eliminat.


#!/bin/bash

# Verificăm dacă sunt furnizate două directoare ca argumente
if [ "$#" -ne 2 ]; then
    echo "Usage: $0 <director_sursă> <director_destinație>" >&2
    exit 1
fi

# Verificăm dacă cele două argumente sunt directoare valide
if ! [ -d "$1" ] || ! [ -d "$2" ]; then
    echo "Ambele argumente trebuie să fie directoare valide." >&2
    exit 1
fi

# Mutăm subramura din directorul destinatar în directorul sursă
mv -n "$2"/* "$1"/ || { echo "Nu s-au putut muta fișierele și directoarele." >&2; exit 1; }

# Adăugăm extensia ".unu" la fiecare fișier din directorul sursă
for file in "$1"/*; do
    mv "$file" "$file.unu"
done




PB 4 LAB 6

Pentru o lista de nume de fisiere data prin parametrii si pentru un director dat ca prim parametru, sa se afiseze pentru fiecare nume de fisier toate subdirectoarele in care acesta apare. Rezultatul va fi afisat la iesirea standard in formatul urmator:
Pentru fiecare fisier din linia de comanda, subdirectoarele vor fi afisate pe aceeasi linie separate prin spatiu. Linia va incepe cu numele fisierului urmat de ":" si apoi lista de subdirectoare separate prin spatiu. Exemplu de output:
fis1:subdir11 subdir12 subdir13
fis2:subdir22 subdir22


if ! [[ -d $1 ]]; then
        echo "nu este director">&2
        exit 1
fi


director=$1
shift
for fisier in "$@"; do
        if [ ! -f $fisier ]; then
                echo "$fisier nu este fisier">&2
        else
                printf "%s:" "$fisier"

                for subdir in "$director"/*; do
                        if grep -q "$fisier" "subdir"; then
                                printf " %s" "$(basename "$subdir")"
                        fi
                done

        fi
        printf "\n"
done


ceva nu e bine zice ca denisa.txt  nu e fisier







PB 6 LAB 6
Se da un nume de director ca parametru. Sa se afiseze o lista a tuturor numelor fisierelor si directoarelor care apar in structura arborescenta din directorul dat si pentru fiecare sa se afiseze si cate de cate ori apare fiecare in aceasta structura. Rezultatul va fi afisat sortat la iesirea standard, cate o linie pt fiecare fisier/ director din structura si numarul aparitiei, separate prin spatiu. Exemplu de output:
director1 3
fis1 1
fis2 2

-type f fisier
-o = or = sau
-type d director


#!/bin/bash

if [ $# -ne 1 ]; then
    echo "trebuie 1 singur argument care trb sa fie si director"
    exit 1
fi



if ! [[ -d $1 ]]; then
        echo "nu este director">&2
        exit 1
fi

find "$1" -type f -o -type d | sort | uniq -c | sed 's/ /-/'






PB 7 LAB 6
 

#!/bin/bash

if [ ! -f "$1" ]
then
        echo "trebuie sa fie fisier" >&2
        exit 1
fi

mkdir -p dictionarcifre

for digit in {0..9}; do
        grep -E "^$digit" "$1" | sort -u > "dictionarcifre/$digit"
done





PB 8 LAB 6

Se dau ca parametri mai multe nume de fisiere, fiecare fisier reprezentand un transport de marfa. Un transport de marfa poate fi de tip "IN", insemnand ca acea marfa intra in depozit, sau "OUT" insemnand ca acea marfa iese din depozit. Pe prima linie a unui fisier de transport se gaseste informatia despre tipul de transport ("IN" sau "OUT"), iar pe restul liniilor se gasesc informatii despre produsele transportate. Pe fiecare linie gaseste denumirea produsului si cantitatea, separate prin virgula. In fisierul "depozit.csv", se afla inventarul produselor din depozit, in acelasi format, fiecare produs pe cate o linie, denumirea si cantitatea fiind separate prin virgula. Se cere sa se actualizeze inventarul din depozit (fisierul "depozit.csv", in functie de transpoturile care au avut loc. Nu se va afisa nimic la iesirea standard.
Exemplu de fisier depozit.csv:
ciment,4
adeziv,9
kit de rosturi,10
Exemplu fisier de transport:
IN
ciment,12

#!/bin/bash

# Verificăm dacă a fost furnizat cel puțin un fișier de transport și fișierul de depozit
if [ $# -lt 2 ]; then
    echo "Usage: $0 <depozit.csv> <fisier_transport1> [<fisier_transport2> ...]"
    exit 1
fi

# Verificăm dacă fișierul de depozit există
if [ ! -f "$1" ]; then
    echo "Fișierul de depozit $1 nu există sau nu este un fișier."
    exit 1
fi

# Parcurgem fiecare fișier de transport
for fisier_transport in "${@:2}"; do
    # Verificăm dacă fișierul de transport există
    if [ ! -f "$fisier_transport" ]; then
        echo "Fișierul de transport $fisier_transport nu există sau nu este un fișier."
        continue
    fi
    
    # Citim tipul de transport din primul rând al fișierului de transport
    tip_transport=$(head -n 1 "$fisier_transport")
sau

read -r tip_transport < "$fisier_transport"
    
    # Parcurgem restul liniilor pentru a actualiza inventarul
    tail -n +2 "$fisier_transport" | while IFS=, read -r produs cantitate; do
        # Verificăm tipul de transport și actualizăm inventarul
        if [ "$tip_transport" = "IN" ]; then
            # Adăugăm cantitatea la inventar pentru produsul respectiv
            sed -i "/^$produs,/ s/,.*$/$((cantitate + $(grep -oP "^$produs,\K\d+" "$1")))/" "$1"
        elif [ "$tip_transport" = "OUT" ]; then
            # Scădem cantitatea din inventar pentru produsul respectiv
            sed -i "/^$produs,/ s/,.*$/$(( $(grep -oP "^$produs,\K\d+" "$1") - cantitate))/g" "$1"
        fi
    done
done



sau

#!/bin/bash

# Verificăm dacă a fost furnizat cel puțin un fișier de transport și fișierul de depozit
if [ $# -lt 2 ]; then
    echo "Usage: $0 <depozit.csv> <fisier_transport1> [<fisier_transport2> ...]"
    exit 1
fi

# Verificăm dacă fișierul de depozit există
if [ ! -f "$1" ]; then
    echo "Fișierul de depozit $1 nu există sau nu este un fișier."
    exit 1
fi

# Parcurgem fiecare fișier de transport
for fisier_transport in "${@:2}"; do
    # Verificăm dacă fișierul de transport există
    if [ ! -f "$fisier_transport" ]; then
        echo "Fișierul de transport $fisier_transport nu există sau nu este un fișier."
        continue
    fi
    
    # Citim tipul de transport din prima linie a fișierului de transport
    read -r tip_transport < "$fisier_transport"
    
    # Parcurgem restul liniilor pentru a actualiza inventarul
    tail -n +2 "$fisier_transport" | while IFS=, read -r produs cantitate; do
        # Verificăm tipul de transport și actualizăm inventarul
        if [ "$tip_transport" = "IN" ]; then
            # Adăugăm cantitatea la inventar pentru produsul respectiv
            awk -F',' -v produs="$produs" -v cantitate="$cantitate" 'BEGIN{OFS=","} $1 == produs {$2 += cantitate}1' "$1" > temp.csv && mv temp.csv "$1"
        elif [ "$tip_transport" = "OUT" ]; then
            # Scădem cantitatea din inventar pentru produsul respectiv
            awk -F',' -v produs="$produs" -v cantitate="$cantitate" 'BEGIN{OFS=","} $1 == produs {$2 -= cantitate}1' "$1" > temp.csv && mv temp.csv "$1"
        fi
    done
done




PB 9 LAB 6
Intr-un proiect de tip .C, a avut loc o eroare de scriere si parametrul unei functii trebuie inlocuit cu o valoare specifica. Scrieti un script care, pentru o functie data, pt fiecare apel al acesteia, inlocuieste parametrul functiei cu o valoare data. Scriptul primeste prin primul parametru directorul in care se afla proiectul, prin al doilea parametru numele functiei si prin al treilea parametru valoare cu care trebuie inlocuit. Scriptul afiseaza la iesirea standard numarul de inlocuiri pe care le-a efectuat.  Consideram ca trebuie facute inlocuiri doar in fisierele cu extensia ".c"


#!/bin/bash

# Verificăm dacă sunt furnizate exact trei argumente
if [ $# -ne 3 ]; then
    echo "Usage: $0 <director_proiect> <nume_functie> <valoare_inlocuire>"
    exit 1
fi

# Directorul proiectului
director_proiect="$1"

# Numele funcției și valoarea de înlocuire
nume_functie="$2"
valoare_inlocuire="$3"

# Verificăm dacă directorul există și este un director valid
if [ ! -d "$director_proiect" ]; then
    echo "Directorul $director_proiect nu există sau nu este un director."
    exit 1
fi

# Numărul total de înlocuiri efectuate
numar_inlocuiri=0

# Parcurgem fiecare fișier .c din directorul proiectului
find "$director_proiect" -type f -name "*.c" | while IFS= read -r fisier_c; do
    # Numărăm de câte ori apare funcția în fișier
    numar_aparitii=$(grep -o "\b$nume_functie\b" "$fisier_c" | wc -l)
    
    # Dacă funcția apare cel puțin o dată, efectuăm înlocuirile
    if [ "$numar_aparitii" -gt 0 ]; then
        # Efectuăm înlocuirea și numărăm de câte ori s-a făcut
        numar_inlocuiri_fisier=$(sed -i "s/\b$nume_functie\b/$valoare_inlocuire/g" "$fisier_c" | wc -l)
        
        # Actualizăm numărul total de înlocuiri
        numar_inlocuiri=$((numar_inlocuiri + numar_inlocuiri_fisier))
    fi
done

# Afișăm numărul total de înlocuiri efectuate
echo "Numărul total de înlocuiri efectuate: $numar_inlocuiri"



PB 10 LAB 6
O companie de consiliera financiara are nevoie de un script pt automatizarea unui proces de calcul.
Pt fiecare client, exista un fisier denumit cu numele clientului avand extensia ".txt". Fisierul contine pe prima linie un numar ce reprezinta salariul clientului (venitul lunar), iar pe a doua linie, alte numere separate prin spatiu, ce reprezinta cheltuielile lunare ale acelui client. Compania are nevoie sa calculeze pt fiecare client fondul de urgenta si in cat timp poate fi acumulat. Fondul de urgent reprezinta suma ce acopera cheltuielile pe o durata de 6 luni. Scrieti un script care primeste ca parametrii numele clientilor si pt fiecare client adauga in fisierul acestuia o linie ce contine, separate prin spatiu, suma fondului de urgenta si in cate luni poate acumula clientul aceasta suma. 


#!/bin/bash

# Verificăm dacă sunt furnizate argumente
if [ $# -eq 0 ]; then
    echo "Usage: $0 <client1> [<client2> ...]"
    exit 1
fi

# Iterăm prin fiecare client furnizat ca parametru
for client in "$@"; do
    fisier_client="$client.txt"
    
    # Verificăm dacă fișierul clientului există
    if [ ! -f "$fisier_client" ]; then
        echo "Fișierul pentru clientul $client nu există."
        continue
    fi
    
    # Citim venitul lunar și cheltuielile lunare din fișierul clientului
    read -r venit_lunar < "$fisier_client"
    read -r -a cheltuieli_lunare < "$fisier_client"

    # Calculăm suma fondului de urgență (cheltuieli pe 6 luni)
    fond_urgenta=$((6 * ${cheltuieli_lunare[*]}))

    # Calculăm timpul necesar pentru a acumula fondul de urgență (în luni)
    timp_acumulare=$((fond_urgenta / venit_lunar))

    # Adăugăm în fișierul clientului noua linie cu suma fondului de urgență și timpul de acumulare
    echo "$fond_urgenta $timp_acumulare" >> "$fisier_client"

    echo "Pentru clientul $client s-a adăugat o linie în fișierul $fisier_client."
done



sau

#!/bin/bash

# Verificăm dacă sunt furnizate argumente
if [ $# -eq 0 ]; then
    echo "Usage: $0 <client1> [<client2> ...]"
    exit 1
fi

# Funcție pentru calcularea fondului de urgență și a timpului de acumulare
calculeaza_fond_urgenta() {
    venit_lunar=$1
    cheltuieli_lunare=$2

    # Calculăm suma fondului de urgență (cheltuieli pe 6 luni)
    fond_urgenta=$((6 * cheltuieli_lunare))

    # Calculăm timpul necesar pentru a acumula fondul de urgență (în luni)
    timp_acumulare=$((fond_urgenta / venit_lunar))

    # Afișăm suma fondului de urgență și timpul de acumulare
    echo "$fond_urgenta $timp_acumulare"
}

# Iterăm prin fiecare client furnizat ca parametru
for client in "$@"; do
    fisier_client="$client.txt"
    
    # Verificăm dacă fișierul clientului există
    if [ ! -f "$fisier_client" ]; then
        echo "Fișierul pentru clientul $client nu există."
        continue
    fi

    # Citim venitul lunar și cheltuielile lunare din fișierul clientului
    read -r venit_lunar < "$fisier_client"
    read -r -a cheltuieli_lunare < "$fisier_client"

    # Apelăm funcția calculeaza_fond_urgenta cu venitul lunar și cheltuielile lunare și salvăm rezultatul într-o variabilă
    rezultat=$(calculeaza_fond_urgenta "$venit_lunar" "${cheltuieli_lunare[*]}")

    # Adăugăm rezultatul în fișierul clientului
    echo "$rezultat" >> "$fisier_client"

    echo "Pentru clientul $client s-a adăugat o linie în fișierul $fisier_client."
done






PB 1 LAB 6
Se da prin parametru numele unui fisier ".C". Sa se determine, pentru fiecare functie "int" definita in program, de care ori este apelata. Rezultatul va afisat la iesirea standard sub forma urmatoare:
nume_functie numar_de_apeluri
Exemplu de output:
adunare 3
scadere 3

Se da un program C. Sa se determine, pentru fiecare functie definita în program, numarul locurilor unde este apelata, afisându-se si numerele de linii din program unde apar aceste apeluri

for i in `grep "function " program.txt| sed 's/.*function \([a-zA-Z0-9]*\) .*/\1/'`
do
apare=`grep -c $i program.txt`
apare1=$((apare-1))
linie=`grep -n $i program.txt | cut -d: -f1 | tail -n $apare1`
echo "Functia: $i apare de $((apare=apare-1)) ori."
echo "Este apelata pe liniile: $linie"
done










LAB 4 1 AWK

 
#!/bin/bash

# Verificăm dacă sunt furnizate argumente în linia de comandă
if [ $# -eq 0 ]; then
    echo "Utilizare: $0 fisier1 fisier2 ..."
    exit 1
fi

# Iterăm prin fiecare fișier din argumentele liniei de comandă
for fisier in "$@"; do
    if [ ! -f "$fisier" ]; then
        echo "$fisier nu este un fișier valid."
        continue
    fi

    # Inițializăm contoarele pentru vocale și consoane
    vowels=0
    consonants=0

    # Citim conținutul fișierului linie cu linie și numărăm vocalele și consoanele
    while IFS= read -r line; do
        for (( i = 0; i < ${#line}; i++ )); do
            char="${line:$i:1}"
            # Verificăm dacă caracterul este o vocală (ignorând distincția între litere mari și mici)
            if [[ "$char" =~ [aeiouAEIOU] ]]; then
                (( vowels++ ))
            # Verificăm dacă caracterul este o consoană (ignorând distincția între litere mari și mici)
            elif [[ "$char" =~ [bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ] ]]; then
                (( consonants++ ))
            fi
        done
    done < "$fisier"

    # Calculăm raportul dintre numărul de vocale și numărul de consoane
    if [ "$consonants" -ne 0 ]; then
        ratio=$(echo "scale=2; $vowels / $consonants" | bc)
    else
        ratio="Infinit"
    fi

    # Afisăm raportul pentru fiecare fișier
    echo "Raportul dintre numarul de vocale si numarul de consoane pentru $fisier este: $ratio"
done



{F[FILENAME]++

for(i=1;i<=NF;i++){
	
if(length($i) == 1){
		
if ($i == "a" || $i == "e" || $i == "i" || $i == "o" || $i == "u" || $i == "A" || $i == "E" || $i == "I" || $i == "O" || $i == "U")
			
voc[FILENAME]++;
		
else
			
cons[FILENAME]++;
	
}
	
else{
	litera=substr($i,1,1);
	
if (litera== "a" || litera == "e" || litera == "i" || litera== "o" || litera == "u" || $i == "A" || $i == "E" || $i == "I" || $i == "O" || $i == "U")
		
voc[FILENAME]++;
	
else
		
cons[FILENAME]++;
	
for(j=1;j<length($i);j++){
		
litera=substr($i,j+1,1);
		
if (litera== "a" || litera == "e" || litera == "i" || litera== "o" || litera == "u" || $i == "A" || $i == "E" || $i == "I" || $i == "O" || $i == "U" )

voc[FILENAME]++;
		
else
			
cons[FILENAME]++;}

}
}
}

END {for (f in F)
print f," " ,voc[FILENAME], "/", cons[FILENAME];
}





15. Sa se calculeze pentru fiecare din fisierele date ca parametrii in linia de comanda produsul tuturor numerelor de doua cifre din fisier. 

#!/bin/bash

cifre() {
        local num=$1
        if [[ $num =~ ^[0-9]{2}$ ]]; then
                return 0
        else
                return 1
        fi
}


if [ $# -eq 0 ]; then
    echo "Utilizare: $0 fisier1 fisier2 ..."
    exit 1
fi


for fisier in "$@"; do
        if [ ! -f "$fisier" ]; then
                echo "$fisier nu e fisier"
                continue
        fi


        produs=1

        # iteram fiecare nr din fisier
        while read -r number; do
                if cifre "$number"; then
                        produs=$((produs*number))
                fi
        done < "$fisier"
        echo "prod din $file este: $produs"
done



-------

SAU DIRECT 

while read -r number; do
        if [[ $number =~ ^[0-9]{2}$ ]]; then
            produs=$((produs * number))
        fi
    done < "$fisier"



-----------------------------------------

numar par / impar

#!/bin/bash

# Funcție pentru validarea dacă un număr este impar
is_odd() {
    local num=$1
    if (( num % 2 != 0 )); then
        return 0  # Este impar
    else
        return 1  # Nu este impar
    fi
}

# Exemplu de utilizare al funcției
if is_odd 5; then
    echo "Numărul este impar."
else
    echo "Numărul nu este impar."
fi





--------
nr vocale consoane 

#!/bin/bash

# Funcție pentru numărarea vocalelor și consoanelor într-un și>count_vowels_and_consonants() {
    local string="$1"
    local vowels=0
    local consonants=0
    local char

    # Parcurgem fiecare caracter din șir
    for (( i = 0; i < ${#string}; i++ )); do
        char="${string:$i:1}"
        # Verificăm dacă caracterul este o vocală (ignorând di>        if [[ "$char" =~ [aeiouAEIOU] ]]; then
            (( vowels++ ))
        # Verificăm dacă caracterul este o consoană (ignorând >        elif [[ "$char" =~ [bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQ>
            (( consonants++ ))
        fi
    done

    # Afișăm rezultatul
    echo "Numărul de vocale: $vowels"
    echo "Numărul de consoane: $consonants"
}

# Verificăm dacă sunt furnizate argumente în linia de comandă
if [ $# -eq 0 ]; then
    echo "Utilizare: $0 nume_fisier"
    exit 1
fi


# Verificăm dacă fișierul dat ca argument există și este un fi>fisier="$1"
if [ ! -f "$fisier" ]; then
    echo "$fisier nu există sau nu este un fișier regulat."
    exit 1
fi

# Citim conținutul fișierului și apelăm funcția pentru numărar>while read -r line; do
    count_vowels_and_consonants "$line"
done < "$fisier"


sau 

#!/bin/bash

# Verificăm dacă sunt furnizate argumente în linia de comandă
if [ $# -eq 0 ]; then
    echo "Utilizare: $0 nume_fisier"
    exit 1
fi

# Verificăm dacă fișierul dat ca argument există și este un fișier regulat
fisier="$1"
if [ ! -f "$fisier" ]; then
    echo "$fisier nu există sau nu este un fișier regulat."
    exit 1
fi

# Inițializăm contoarele pentru vocale și consoane
vowels=0
consonants=0

# Citim conținutul fișierului linie cu linie și numărăm vocalele și consoanele
while IFS= read -r line; do
    for (( i = 0; i < ${#line}; i++ )); do
        char="${line:$i:1}"
        # Verificăm dacă caracterul este o vocală (ignorând distincția între litere mari și mici)
        if [[ "$char" =~ [aeiouAEIOU] ]]; then
            (( vowels++ ))
        # Verificăm dacă caracterul este o consoană (ignorând distincția între litere mari și mici)
        elif [[ "$char" =~ [bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ] ]]; then
            (( consonants++ ))
        fi
    done
done < "$fisier"

# Afișăm rezultatul
echo "Numărul de vocale: $vowels



 


--------------------------------------------------------

s1 Write a shell script which takes as parameters a file name followed by several words. 
The script will delete all occurrences of the words given as parameters in the given file.

#!/bin/bash


file=$1

if ! [ -f $file ];  then
        echo "$1 nu e fisier">&2
        exit 1
fi

shift

for word in "$@"; do
        if ! [[ $word =~ ^[a-zA-Z]+$ ]];  then
                echo "$word nu e cuvant" >&2
                exit
        else
                sed -i "s/\b$word\b//g" "$file"
 #b delimitator inceput sfarsit cuvant intreg

        fi
done

# Ștergem liniile goale și liniile care conțin doar spații
sed -i '/^\s*$/d' "$file"


--------------------------------------------------------

g1

Write a shell script which takes as parameter a directory name. The script will display the content of all text files in given directory and its subdirectories.

dir=$1

if ! [ -d $dir ];  then
        echo "$1 nu e director">&2
        exit 1
fi


find "$dir" -type f -exec cat {} \;

find "$dir" -type f -name "*.txt" -exec cat {} \; | sort 
 						  | sort -r
--------------------------------------------------------


s2

Write a shell script which takes as parameters a text followed by several file names. The script will delete all the lines which contain the text given as parameter in all given files.

#!/bin/bash

# Check if the number of arguments is at least two
if [ "$#" -lt 2 ]; then
    echo "Usage: $0 text file1 [file2 ...]" >&2
    exit 1
fi

# Extract the text to be deleted
text="$1"
shift

# Iterate through each file
for file in "$@"; do
    # Check if the file exists and is a regular file
    if [ ! -f "$file" ]; then
        echo "$file is not a valid file." >&2
        continue
    fi

    # Remove lines containing the specified text from the file
    sed -i "/$text/d" "$file"   STERGE TOATA LINIA CE CONTINE CUVANTUL
    echo "Lines containing '$text' have been removed from $file."
done




--------------------------------------------------------

g2
Write a shell script which takes as parameters a word followed by several file names. The shell will display the names of the files containing the given word and the total number of these files.

#!/bin/bash

# Check if the number of arguments is at least two
if [ "$#" -lt 2 ]; then
    echo "Usage: $0 word file1 [file2 ...]" >&2
    exit 1
fi

# Extract the word to search for
word="$1"
shift

# Initialize a counter for the number of files containing the word
count=0

# Iterate through each file
for file in "$@"; do
    # Check if the file exists and is a regular file
    if [ ! -f "$file" ]; then
        echo "$file is not a valid file." >&2
        continue
    fi
    
    # Search for the word in the file
    if grep -q "$word" "$file"; then
        # Increment the counter and display the filename
        ((count++))
        echo "$file contains the word '$word'."
    fi
done

# Display the total number of files containing the word
echo "Total number of files containing '$word': $count"


--------------------------------------------------------
s3

Write a shell script which takes as parameters a word followed by several file names. The shell will delete all the lines containing the given word in all given files.


#!/bin/bash

# Check if the number of arguments is at least two
if [ "$#" -lt 2 ]; then
    echo "Usage: $0 word file1 [file2 ...]" >&2
    exit 1
fi

# Extract the word to delete
word="$1"
shift

# Iterate through each file
for file in "$@"; do
    # Check if the file exists and is a regular file
    if [ ! -f "$file" ]; then
        echo "$file is not a valid file." >&2
        continue
    fi
    
    # Delete lines containing the specified word from the file
    sed -i "/$word/d" "$file"
    echo "Lines containing '$word' have been deleted from $file."
done



--------------------------------------------------------
 g3

Write a shell script which takes as parameters a few directory names. The script will display the names of all binary files in the given directories and their subdirectories.

gcc -o hello hello.c

#!/bin/bash

# Check if the number of arguments is at least one
if [ "$#" -lt 1 ]; then
    echo "Usage: $0 directory1 [directory2 ...]" >&2
    exit 1
fi

# Iterate through each directory
for directory in "$@"; do
    # Check if the directory exists
    if [ ! -d "$directory" ]; then
        echo "$directory is not a valid directory." >&2
        continue
    fi

    # Display the names of binary files in the directory and its subdirectories
    echo "Binary files in $directory and its subdirectories:"
    find "$directory" -type f -executable -exec file {} \; | grep "ELF" | cut -d: -f1
done


--------------------------------------------------------
s4

Write a shell script which takes as parameters an uppercase letter followed by several file names. The script will add the given letter in the front of each lowercase on each line in all given files.

#!/bin/bash

# Check if the number of arguments is at least two
if [ "$#" -lt 2 ]; then
    echo "Usage: $0 uppercase_letter file1 [file2 ...]" >&2
    exit 1
fi

# Extract the uppercase letter to add
uppercase_letter="$1"
shift

# Validate that the uppercase letter is a single uppercase letter
if [[ ! "$uppercase_letter" =~ ^[A-Z]$ ]]; then
    echo "Error: The first argument must be a single uppercase letter." >&2
    exit 1
fi

# Iterate through each file
for file in "$@"; do
    # Check if the file exists and is a regular file
    if [ ! -f "$file" ]; then
        echo "$file is not a valid file." >&2
        continue
    fi

    # Add the uppercase letter in front of each lowercase letter on each line
    sed -i "s/\b\([a-z]\)/$uppercase_letter\1/g" "$file"
    echo "Uppercase letter '$uppercase_letter' added in front of lowercase letters in $file."
done


--------------------------------------------------------
g4

Write a shell script which takes as parameter a group name (ex: gr821). The script will display the given group name followed by the list of all users that belongs to that group.
#!/bin/bash

# Check if the input file exists
input_file="group.txt"
if [ ! -f "$input_file" ]; then
    echo "Input file '$input_file' not found." >&2
    exit 1
fi

# Read the group name from the input file
group_name=$(grep -o '^[^#]*' "$input_file" | awk 'NF' | head -n 1)

# Check if the group name is provided
if [ -z "$group_name" ]; then
    echo "No group name found in the input file." >&2
    exit 1
fi

# Get the list of users belonging to the specified group
users=$(getent group "$group_name" | cut -d: -f4)

# Check if the group exists and has users
if [ -z "$users" ]; then
    echo "Group $group_name does not exist or has no users."
    exit 1
fi

# Display the group name followed by the list of users
echo "Group: $group_name"
echo "Users: $users"





--------------------------------------------------------
s5

Write a shell script which takes as parameters several file names. The script will delete all words that contain at least one digit from all given files.


#!/bin/bash

# Check if file names are provided as arguments
if [ "$#" -eq 0 ]; then
    echo "Usage: $0 file1 [file2 ...]" >&2
    exit 1
fi

# Iterate through each file
for file in "$@"; do
    # Check if the file exists and is a regular file
    if [ ! -f "$file" ]; then
        echo "$file is not a valid file." >&2
        continue
    fi

    # Delete words containing at least one digit from the file
    sed -i 's/[[:alnum:]]*[0-9][[:alnum:]]*//g' "$file"
    echo "Words containing digits have been deleted from $file."
done




--------------------------------------------------------
g5

If the string is not empty, the -z expression evaluates to false.


#!/bin/bash

# Check if a command name is provided as an argument
if [ "$#" -ne 1 ]; then
    echo "Usage: $0 command_name" >&2
    exit 1
fi

command_name="$1"

# Get the list of user accounts running the specified command
users=$(ps -eo user,cmd | awk -v cmd="$command_name" '$2 == cmd { print $1 }' | sort -u)

# Check if the command is running for any user
if [ -z "$users" ]; then
    echo "No user is running the command: $command_name"
    exit 0
fi

# Display the list of user accounts running the specified command
echo "Users running the command '$command_name':"
echo "$users"




--------------------------------------------------------
s6

Write a shell script which takes as parameters a lowercase letter followed by several file names. The script will replace any special character with the given letter in all files given as parameters.

#!/bin/bash

# Check if at least two arguments are provided
if [ "$#" -lt 2 ]; then
    echo "Usage: $0 lowercase_letter file1 [file2 ...]" >&2
    exit 1
fi

# Extract the lowercase letter
lowercase_letter="$1"
shift

# Check if the lowercase letter is a single lowercase letter
if ! [[ "$lowercase_letter" =~ ^[a-z]$ ]]; then
    echo "Error: The first argument must be a single lowercase letter." >&2
    exit 1
fi

# Iterate through each file
for file in "$@"; do
    # Check if the file exists and is a regular file
    if [ ! -f "$file" ]; then
        echo "$file is not a valid file." >&2
        continue
    fi

    # Replace special characters with the lowercase letter in the file
    sed -i "s/[^[:alnum:]]/$lowercase_letter/g" "$file"
    echo "Special characters replaced with '$lowercase_letter' in $file."
done




--------------------------------------------------------

g6

Write a shell script which takes as parameters a short month name followed by a day number (ex: Mar 8). The script will display all user accounts that were connected to the server that day of month.

#!/bin/bash

# Check if exactly two arguments are provided
if [ "$#" -ne 2 ]; then
    echo "Usage: $0 month day_number" >&2
    exit 1
fi

month_name="$1"
day_number="$2"

# Validate month name and convert it to lowercase
case "$(echo "$month_name" | tr '[:upper:]' '[:lower:]')" in
    "jan"|"feb"|"mar"|"apr"|"may"|"jun"|"jul"|"aug"|"sep"|"oct"|"nov"|"dec")
        ;;
    *)
        echo "Error: Invalid month name. Please provide a valid short month name (e.g., Jan, Feb, etc)." >&2
        exit 1
        ;;
esac

# Validate day number
if ! [[ "$day_number" =~ ^[1-9][0-9]*$ ]]; then
    echo "Error: Invalid day number. Please provide a valid day number (e.g., 1, 2, ..., 31)." >&2
    exit 1
fi

# Get the list of user accounts connected to the server on the specified day
users=$(last | awk -v month="$month_name" -v day="$day_number" '$5 == month && $6 == day { print $1 }' | sort -u)

# Check if any user accounts were connected on the specified day
if [ -z "$users" ]; then
    echo "No user accounts were connected to the server on $month_name $day_number."
else
    echo "User accounts connected to the server on $month_name $day_number:"
    echo "$users"
fi

--------------------------------------------------------
s15	Write a shell script which takes as parameters several file names. The script will delete the last 3 characters on each line in the given files.


#!/bin/bash

# Check if any filenames are provided as arguments
if [ "$#" -eq 0 ]; then
    echo "Usage: $0 file1 [file2 file3 ...]" >&2
    exit 1
fi

# Iterate over each file provided as argument
for file in "$@"; do
    # Check if the file exists
    if [ ! -f "$file" ]; then
        echo "$file does not exist or is not a file" >&2
        continue
    fi
    
    # Delete the last 3 characters on each line in the file using sed
    sed -i 's/...$//' "$file"
    echo "Last 3 characters deleted from each line in $file"
done





g15	Write a shell script which takes as parameters several file names. The script will display all the lines in the given files that contain only lowercase letters.


#!/bin/bash

# Check if any filenames are provided as arguments
if [ "$#" -eq 0 ]; then
    echo "Usage: $0 file1 [file2 file3 ...]" >&2
    exit 1
fi

# Iterate over each file provided as argument
for file in "$@"; do
    # Check if the file exists
    if [ ! -f "$file" ]; then
        echo "$file does not exist or is not a file" >&2
        continue
    fi
    
    # Display lines containing only lowercase letters
    echo "Lines with only lowercase letters in $file:"
    grep '^[a-z]*$' "$file"
    echo
done


--------------------------------------------------------

s14	Write a shell script which takes as parameters a text followed by several file names. The script will insert the given text after the 1st line in the given files.

#!/bin/bash

# Check if at least two arguments are provided (text and file names)
if [ "$#" -lt 2 ]; then
    echo "Usage: $0 text file1 [file2 file3 ...]" >&2
    exit 1
fi

# Extract the text to be inserted (first argument)
text="$1"
shift

# Iterate over each file provided as argument
for file in "$@"; do
    # Check if the file exists
    if [ ! -f "$file" ]; then
        echo "$file does not exist or is not a file" >&2
        continue
    fi
    
    # Insert the text after the first line in the file using sed
    sed -i "1 a\\$text" "$file"
    echo "Inserted text after the first line in $file"
done




g14	Write a shell script which takes as parameters several file names. The script will display all the lines in the given files that contain only uppercase letters.

grep '^[A-Z]*$' "$file"


--------------------------------------------------------
s13	Write a shell script which takes as parameters several file names. The script will delete the first 2 characters on each line in the given files.

for file in "$@"; do
    # Check if the file exists
    if [ ! -f "$file" ]; then
        echo "$file does not exist or is not a file" >&2
        continue
    fi
    
    # Delete the first 2 characters on each line in the file using sed
    sed -i 's/^..//' "$file"
    echo "First 2 characters deleted from each line in $file"
done




g13	Write a shell script which takes as parameters several file names. The script will display all the lines in the given files that don't contain any letter or digit.

 grep -E -v "[a-zA-Z0-9]" "$file"

--------------------------------------------------------
s12	Write a shell script which takes as parameters a lowercase letter followed by several file names. The script will replace each digit with the letter given as a parameter in all given files.

letter="$1"
shift
sed -i "s/[0-9]/$letter/g" "$file"
echo "Replaced digits with $letter in $file"



g12	Write a shell script which takes as parameters a file name followed by several directory names. The script will delete all files whose names are given in the file received as first parameter in the given directories and their subdirectories.

while IFS= read -r file; do
        # Delete the file if it exists
        if [ -f "$dir/$file" ]; then
            rm "$dir/$file"
            echo "Deleted $dir/$file"
        fi
    done < "$file_name"

--------------------------------------------------------


s11	Write a shell script which takes as parameter a HTML file name. The script will convert the given HTML file to a text file (all HTML tags will be removed).


g11	Write a shell script which takes as parameters several user accounts (ex: gmae0221 jpae0229). The script will display those user accounts (from those given as parameters) that have never been connected to the server.

for user in "$@"; do
    # Check if the user has ever logged in
    if last | grep -q "^$user"; then
        echo "$user has logged in before"
    else
        echo "$user has never logged in"
    fi
done

--------------------------------------------------------

s10	Write a shell script which takes as parameters several file names. The script will interchange the 1st word with 3rd word in each line of the given files. The words shall contain only letters or numbers and shall be separated by any other character.
 

sed -i 's/^\(\w\+\)\(\W\+\)\(\w\+\)/\3\2\1/' "$file"


sau

for file in "$@"; do
    # Check if the file exists
    if [ ! -f "$file" ]; then
        echo "$file does not exist or is not a file" >&2
        continue
    fi
    
    # Interchange first and third words in each line of the file
    awk '{temp=$1; $1=$3; $3=temp; print}' "$file" > "$file.tmp"
    mv "$file.tmp" "$file"
    
    echo "Interchanged first and third words in $file"
done



g10	Write a shell script which takes as parameters several user accounts (ex: gmae0221 jpae0229). The script will display all directories in each user's home directory that have write permission for the group of which the owner belongs.


--------------------------------------------------------
s9	Write a shell script which takes as parameters several file names. The script will delete the 2nd and 4th word in each line of the given files. The words shall contain only letters or numbers and shall be separated by spaces.
 
 sed -i 's/\(\([^[:space:]]\+[[:space:]]\+\)\{1\}\)\([^[:space:]]\+[[:space:]]\+\)\([^[:space:]]\+[[:space:]]\+\)\([^[:space:]]\+[[:space:]]\+\)/\1\4\3\5/' "$file"

--------------------------------------------------------

s8	Write a shell script which takes as parameters several file names. The script will replace the 3rd word with the 1st word in each line of the given files. The words shall contain only letters or numbers and shall be separated by ":".

awk -F: '{print $1":"$1":"$3}' "$file" > "$file.tmp"
    mv "$file.tmp" "$file"


sed -i 's/^\([^:]*\):\([^:]*\):\([^:]*\)/\1:\1:\3/' "$file"


--------------------------------------------------------
s7	Write a shell script which takes as parameters several file names. The script will replace all lowercase vowels with corresponding uppercase letters in each line of the given files.

sed -i 's/a/A/g; s/e/E/g; s/i/I/g; s/o/O/g; s/u/U/g' "$file"
sau sed -i 'y/aeiouAEIOU/AEIOUAEIOU/' "$file"
    
--------------------------------------------------------


a	2	Sa se afiseze continutul fisierelor date prin parametri, fiecare fisier fiind afisate in ordinea inversa a liniilor; mai intai se afiseaza ultima linie, apoi penultima etc).

for file in "$@"; do
    # Verificăm dacă fișierul există
    if [ ! -f "$file" ]; then
        echo "$file does not exist or is not a file" >&2
        continue
    fi

    # Folosim awk pentru a afișa conținutul fișierului în ordine inversă a liniilor
    echo "Content of $file in reverse order:"
    awk '{a[NR]=$0} END {for(i=NR;i>=1;i--) print a[i]}' "$file"
    echo "-----------------------------------------"
done

--------------------------------------------------------


















Exerciţii - Programare shell
---------------------------------------------------------------------------
1. Să se afișeze conținutul unui fișier de tip text în ordinea inversă a liniilor (mai întai se va afișa ultima linie, apoi penultima etc.).

2. Să se determine și să afișeze linia dintr-un fișier care conține cele mai multe caractere.

3. Să se calculeze și să afișeze numărul de vocale și numărul de consoane dintr-un fișier.

4. Să se afișeze liniile dintr-un fișier în care un cuvânt se repetă de cel puțin 2 ori.

5. Să se determine și să afișeze numărul de numere valide (sau suma lor) dintr-un fișier.


Să se scrie un script shell care îmi listeaza conţinutul directorului curent. Se vor face trei afişări: una sortată după numele fişierelor, alta după timpul ultimului acces la ele şi cea de-a treia, după dimensiunea în bytes a acestora.
Să se afişeze numele tuturor utilizatorilor daţi ca parametri linia de comandă care nu s-au conectat niciodată la serverul curent.
Să se adauge în faţa fiecarei litere mici cuvântul indicat ca prim parametru. Fişierele tratate sunt ceilalţi parametri din linia de comanda.
Să se afişeze liniile din fişiere care conţin un acelaşi cuvânt aflat în pozitii consecutive. Pentru liniile respective să se afişeze şi numărul liniei precum şi cuvântul implicat.(în cadrul fişierului din care face parte).
Să se scrie un program Shell care primeşte ca parametri două nume de directoare şi mută ramura desemnată de cel de-al doilea director ca subramura a primului, dar se copiază numai cu fişierele .txt
Sa se scrie un program care primeste in linia de comanda ca si parametrii doua cuvinte si numele unui fisier. Programul va afisa la iesirea standard continutul fisierului, inlocuind aparitiile primului cuvant cu al doilea.
Fie P un proces ce determină cmmdc a două numere. Folosind o structură adecvată de astfel de procese să se scrie un program ce determină cmmdc a N numere date.

---------------------------------------------------------------------------
1. Să se scrie un script bash care primeşte ca argument un număr natural N şi generează N fişiere de tip text, astfel:
- numele fişierelor vor fi de forma: file_X.txt, unde X = {1, 2, ..., N}
- fiecare fişier generat va conţine doar liniile de la X la X + 5 ale fişierului passwd.fake

2. Să se scrie un script bash care primeşte ca argument un nume de director şi afişează primele 3 linii ale fiecărui fişier de tip text din acel director.

3. Să se scrie un script bash care calculează numărul mediu de linii ale fișierelor de tip text dintr-un director dat ca parametru.
(comenzi: find, file, wc)

4. Să se scrie un script bash care afișează numele fișierelor dintr-un director dat ca parametru care conțin numere de peste 5 cifre.

5. Să se scrie un script bash care afișează primele 5 linii și ultimele 5 linii ale fișierelor de tip text din directorul curent. Dacă un fișier are mai puțin de 10 linii, atunci va fi afişat în întregime.
(comenzi: head, tail, find, file, wc)

6. Să se scrie un script bash care pentru fiecare parametru din linia de comandă:
- dacă e fișier, se vor afișa numele, numărul de caractere și de linii din el (în această ordine)
- dacă e director, numele și câte fișiere conține (inclusiv în subdirectoare).
(comenzi: test, wc, awk, find)

7. Să se scrie un script bash care are ca argumente triplete formate dintr-un nume de fisier, un cuvant si un numar k. Pentru fiecare astfel de triplet, se vor afişa toate liniile fişierului care contin cuvăntul respectiv exact de k ori.
(comenzi: shift, awk)

8. Să se scrie un script bash care afişează, pentru fiecare fişier dat ca argument, linia care apare de cele mai multe ori. Afişarea se va face în ordinea descrescătoare a numărului de apariţii.
(comenzi: sort, uniq, head)

9. Să se scrie un script bash care va afişa toate numele de fişiere dintr-un director dat ca parametru şi din subdirectoarele sale, care au numele mai scurte de 8 caractere. Pentru acestea, dacă sunt fişiere text, li se vor afişa primele 10 linii.

10. Să se scrie un script bash care pentru fiecare fişier cu drepturile 755 dintr-un director (şi subdirectoarele sale) dat ca parametru îi va modifica drepturile de acces în 744. Înainte de a modifica drepturile de acces, script-ul va cere confirmarea din partea utilizatorului (pentru fiecare fişier în parte).
(comenzi: find, chmod, read)







-----------------

PRACTICE EU


echo "Nume,Prenume,Varsta,Oras,Email,Telefon" > practice.txt
echo "Popescu,Mihai,25,Bucuresti,mihai.popescu@example.com,0721123456" >> practice.txt
echo "Ionescu,Ana,30,Cluj,ana.ionescu@example.com,0733123456" >> practice.txt
echo "Dragomir,Andrei,28,Timisoara,andrei.dragomir@example.com,0745123456" >> practice.txt

Găsiți toate liniile din practice.txt care conțin cuvântul "Bucuresti".
Găsiți toate liniile din practice.txt care conțin un număr de telefon cu prefixul "0733".
Găsiți numărul total de linii din practice.txt care conțin cuvântul "example".


Înlocuiți toate aparițiile cuvântului "Cluj" cu "Brasov" în practice.txt.
Ștergeți toate liniile din practice.txt care conțin cuvântul "Telefon".
Adăugați la începutul fiecărei linii din practice.txt numărul său de ordine, începând cu 1.


Afișați doar numele și prenumele din practice.txt.
Calculează media de vârstă a persoanelor din practice.txt.
Sortați liniile din practice.txt în funcție de vârsta persoanelor în ordine descrescătoare.






Să se afişeze numele tuturor fişierelor din linia de comandă care conţin propoziţii în care se repeta un cuvânt mai mult sau egal de două ori.
Se va afişa deasemenea pentru fiecare asemenea caz numărul liniei şi cuvântul implicat.(prima sa apariţie în propoziţia respectivă)


for fisier in $*
do
awk '{
for(i=1;i<=NF-1;i++)
	{nrCuvRep=0
	{for(j=i+1;j<=NF;j++)
		{if($i==$j)
		nrCuvRep=$((c+=1))}}
		if(nrCuvRep>=2)
		{print FILENAME,":",NR,":",$i}
	}
}' $fisier
done





Pentru o lista de nume de fisiere data si pentru un director dat, sa se afiseze pentru fiecare nume de fisier toate subdirectoarele în care acesta apare. Sa se afiseze subdirectoarele în ordinea descrescatoare a datei crearii fisierului.


director=$1
shift 1
for f in $*
do
find $director -name $f -exec ls -1rt "{}" +
done











#!/bin/bash
a=`diff $1 $2 |grep "^[<>].*$"`
c=`echo "$a"|wc -l`
if [ $c -lt 5 ];then
	echo " nu sunt 5 linii diferite"
else
	b=`echo "$a"|head -n 5`
	echo "liniile diferite"
	echo "$b"
fi
Se va srie un script shell care compară conţinutul a doua fişiere text şi va tipări primele 5 linii diferite

#!/bin/bash
file=$1
directory=$2
mkdir $directory
cat $file | while read line; do
	cd $directory
	for i in {0..9};do
		var=${line:0:1}
		if [ "$var" = "$i" ]
			then 
				if [ -e $i ]
				then
					echo "$line" >> "$i"
				else
					echo "$line" > "$i"
				fi
		fi
	done
	
	for i in {10..26};do
		var2=${line:0:2}
		if [ "$var2" = "$i" ]
			then
				if [ -e $i ]
				then
					echo "$line" >> "$i"
				else
					echo "$line" > "$i"
				fi
		fi
	done
cd ..
done

cd $directory
echo $2
for i in {0..26};do
	echo Fisierul "$i" din dictionarul $2 contine :
	cat "$i"
done
Lucaci Stefania
Lucaci
Sa se scrie un program care primeste in linia de comanda ca si parametrii un numar si numele unui fisier. Programul va sterge din fisier aparitiile pare ale numarului.
#toate vocalele litere mici din fisierele date se inlocuiesc cu litere mari coresp 
#si invers
for fis in $*
do
sed y/aeiouAEIOU/AEIOUaeiou/ $fis
done
Să se înlocuiască toate vocalele litere mici din fişierele date ca parametri cu litere mari corespunzatoare şi viceversa.
Lucaci Stefania
Lucaci
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <wait.h>
#include <sys/wait.h>
#include <sys/types.h>


int main(int argc , int *argv[]){

int coef[20],a,v;
int n,i,pid=0,j,created=0,status;
printf("dati gradul polinomului: ");
scanf("%d",&n);
printf("Dati coeficientii polinomului: ");

for(i=0;i<=n;i++)
   {
        scanf("%d",&coef[i]);
        printf("coeficientul termenului x^ %d ",i);
        printf("este %d \n " , coef[i]);
   }
   
printf("Dati punctul in care se calculeaza: ");
scanf("%d",&a);

v=0;   
   //schema horner
for(i=n;i>=0;i--) //n+1 procese pt fiecare paranteza
 { 
if(pid==0)
 {
      pid=fork();//cream copil
      created=0;
      
      if(pid<0)
      {
        perror("Eroare la creare proces fiu\n");
        exit(0);
      }
      
      if(pid==0)//suntem in copil
      {
         
           v=v*a+coef[i];

           if(i==0)
           {
             printf("valoarea polinomului este v= %d\n",v);
                       
           }   
       }
   
    else
    {
     if(created==0)
     {
       created=1;
       wait( & status);
     }
    
     exit(0);
    }
}
else
 exit(0);
}
return 0;
}
Lucaci Stefania
Lucaci
Se dă un polinom A=(a0, a1, ...,an). Să se calculeze valoarea polinomului A într-un punct x, folosind schema lui Horner şi mai multe procese. De exemplu: a0+a1*x+a2*x2 se poate calcula astfel:
last|grep -w $1|grep -w "$2 $3"
Pentru anumiţi utilizatori daţi linia de comandă se cere să se afişeze dacă au lucrat la o anumită dată sau nu.











#echo "Numele de fisiere mai mici de 8 caractere:"
for x in `find $1 -type f`;do
	b=`echo $x | awk 'BEGIN {FS="/"};{print $NF;}'` 
	c=`echo $b | wc -c`
	#echo "Numele de fisier:"
	if [ $c -lt 8 ];then
		echo "Nume de fisier:"
		echo $b, $c
		 
		 `file $x| grep -q "ASCII text"` 
		if [ $? -eq 0 ] 
			then 
			echo "E fisier text:"
			head -10 $x
			fi
	fi

done






Laborator 3
Problema:

Să se scrie un script shell care tot citeşte nume de utilizatori de la intrarea standard (nu ca parametrii!). Pentru fiecare utilizator citit, el va afişa ultimele 3 conectări (logări) ale acestuia (în luna curentă), iar dacă acesta nu s-a conectat deloc în luna curentă va afişa mesajul "userul x nu s-a conectat niciodată".

Script shell:

while true
do
echo "Dati userul dorit:"
read user
last|grep Mar > util
nrL=`grep -w $user util| wc -l`
if test $nrL -gt 0;
 then  grep -w $user util|head -n 3
else
 echo "userul $user nu s-a conectat niciodata luna asta"
fi
done

Labprator 5

Să se afişeze numărul de fişiere din linia de comanda a lui awk, numărul total de cuvinte şi numărul mediu de cuvinte din fişiere.

i=0
total=0
for file in $*
do
  i=$((i += 1))
  c=`awk 'BEGIN{t=0}
  {t=t+NF}
  END{print t}' $file`
  total=$(( total += c))
done
echo "Numarul de fisiere este $i"
echo "Numarul total de cuvinte este $total"
mediu=$(($total/$i))
echo "Numarul mediu de cuvinte este $mediu"

Laborator 6

Problema:
Se dă un fişier text. Să se creeze un director care să conţină 26 de fişiere dicţionar, astfel: primul fişier conţine, ordonate alfabetic, câte unul pe linie, toate cuvintele din fisierul text care încep cu litera 'A', al doilea cu litera 'B' s.a.m.d.

Problema Shell:

#!/bin/bash
file=$1
dir=$2
mkdir $dir
cat $file|while read line;
do
   cd $dir
   for i in {A..Z};
   do
      var=${line:0:1}
      if [ "$var" = "$i" ]
      then
         if [ -e $i ]
         then
           echo "$line" >> "$i"
         else
           echo "$line" > "$i"
         fi
      fi
   done
   cd ..
done
cd $dir
for i in {A..Z};
do
  if [ -e $i ]
  then
     echo Fisierul "$i":
     cat "$i"
  fi
done

Laborator 9

Problema:
Se dă un şir de litere. Folosind în cate un proces pentru fiecare vocala, sa se elimine toate vocalele din acest sir.

Rezolvare:
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>


int status=0;
char sir[50]="AndreEaIoana caUlucristid",vocale[10]="aeiouAEIOU";
int n=strlen(sir),i,j,k,pid=0,trigger=0;
int main(){
i=0;
pid=0;
//printf("Proces parinte %d \n",getpid());
while(i<strlen(vocale)){
if(pid==0)
{pid=fork();
trigger=0;
if(pid==0){
//		printf("Inceput: proces : %d \n",getpid());
	j=0;
	while(j<n){
		if(sir[j]==vocale[i]){
 			for(k=j+1;k<n;k++)
				sir[k-1]=sir[k];
			sir[n-1]='\0';
			n--;
		}
		j++;
	}
i++;
if(i==10){
//                printf("Procesul: %d \n",getpid());
	printf("Sirul este: %s \n",sir);
	}
}
}
else{
	if(trigger==0){
		trigger=1;
//			printf("Inainte de wait %d \n",getpid());
		wait(&status);
//			printf("Dupa wait %d \n",getpid());
	}
	i++;
}
}
return 0;
}



------------------------








Exercises - Shell programming
---------------------------------------------------------------------------
1. Să se scrie un script bash care primeşte ca argument un număr natural N şi generează N fişiere de tip text, astfel:
- numele fişierelor vor fi de forma: file_X.txt, unde X = {1, 2, ..., N}
- fiecare fişier generat va conţine doar liniile de la X la X + 5 ale fişierului passwd.fake

2. Să se scrie un script bash care primeşte ca argument un nume de director şi afişează primele 3 linii ale fiecărui fişier de tip text din acel director.

3. Să se scrie un script bash care calculează numărul mediu de linii ale fișierelor de tip text dintr-un director dat ca parametru.
(comenzi: find, file, wc)

4. Să se scrie un script bash care afișează numele fișierelor dintr-un director dat ca parametru care conțin numere de peste 5 cifre.

5. Să se scrie un script bash care afișează primele 5 linii și ultimele 5 linii ale fișierelor de tip text din directorul curent. Dacă un fișier are mai puțin de 10 linii, atunci va fi afişat în întregime.
(comenzi: head, tail, find, file, wc)

6. Să se scrie un script bash care pentru fiecare parametru din linia de comandă:
- dacă e fișier, se vor afișa numele, numărul de caractere și de linii din el (în această ordine)
- dacă e director, numele și câte fișiere conține (inclusiv în subdirectoare).
(comenzi: test, wc, awk, find)

7. Să se scrie un script bash care are ca argumente triplete formate dintr-un nume de fisier, un cuvant si un numar k. Pentru fiecare astfel de triplet, se vor afişa toate liniile fişierului care contin cuvăntul respectiv exact de k ori.
(comenzi: shift, awk)

8. Să se scrie un script bash care afişează, pentru fiecare fişier dat ca argument, linia care apare de cele mai multe ori. Afişarea se va face în ordinea descrescătoare a numărului de apariţii.
(comenzi: sort, uniq, head)

9. Să se scrie un script bash care va afişa toate numele de fişiere dintr-un director dat ca parametru şi din subdirectoarele sale, care au numele mai scurte de 8 caractere. Pentru acestea, dacă sunt fişiere text, li se vor afişa primele 10 linii.

10. Să se scrie un script bash care pentru fiecare fişier cu drepturile 755 dintr-un director (şi subdirectoarele sale) dat ca parametru îi va modifica drepturile de acces în 744. Înainte de a modifica drepturile de acces, script-ul va cere confirmarea din partea utilizatorului (pentru fiecare fişier în parte).
(comenzi: find, chmod, read)





---------------------

#!/bin/bash

if [ ! -f $1 ]; then
	echo "parametru invalid" >&2
	exit 1
fi

sum=0
k=0
while read line; do
	for number in $line; do
		sum=$((sum+$number))
		k=$((k+1))
	done
done < $1
let medie=$sum/$k
echo $medie



fis.txt
15 4 6 8 12







---------------------

#!/bin/bash

if [ ! -f $1 ]; then
	echo "parametru invalid" >&2
	exit 1
fi

noCorecte=$(grep -Eo "^[1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$" "$1" | wc -l)
noTotale=$(wc -l < "$1")
let noGresite=$noTotale-$noCorecte
echo $noGresite




fis.txt

1234567890123
0123456789012
123456789012
53201231231454
2313210312391
01232315123122121
2345678901234
sdfghjk



#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <string.h>

#define NUME_FIFO "pipe.fifo"

int main(int argc, char* argv[]) {
	FILE *file = fopen(argv[1], "r");
	if(file == NULL) {
		fprintf(stderr, "eroare la fopen()\n");
		return 1;	
	}
	int status = mkfifo(NUME_FIFO, 0666);
	if(status == -1) {
		fprintf(stderr, "eroare la mkfifo()\n");
		return 1;
	}
	char line[100];
	while(fgets(line, 100, file)) {
		pid_t pid = fork();
		if(pid < 0) { // eroare
			fprintf(stderr, "eroare la fork()\n");
			return 1;
		}
		else if(pid == 0) { // copil
			if(strlen(line) == 13 && line[0] != '0') {
				int fd = open(NUME_FIFO, O_WRONLY);
				int primaCifra = line[0] - '0';
				int boyOrGirl = primaCifra % 2;
				write(fd, &boyOrGirl, sizeof(int));
				close(fd);
			}
			fclose(file);
			exit(0);
		}
		else { // parinte
			int fd = open(NUME_FIFO, O_RDONLY);
			int boyOrGirl;
			read(fd, &boyOrGirl, sizeof(int));
			if(boyOrGirl == 0) {
				printf("Este fata!\n");
			}
			else {
				printf("Este baiat!\n");
			}
			close(fd);
			int statusPid;
			wait(&statusPid);
		}
	}
	unlink(NUME_FIFO);
	return 0;
}

---------------------

#!/bin/sh

if [ $# -ne 1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi

if [ ! -f $1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi

sed -i -r  's/un/1/g; s/doi/2/g; s/trei/3/g' $1

exit 0


fis.txt

1.fulga are un mar
2.ana are doar doi peri
3.nimeni n-are trei fructe
4.n-avem



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <ctype.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        perror("parametru invalid\n");
        return 1;
    }
    
    FILE* f;
    f = fopen(argv[1], "r");
    if (f == NULL) {
        perror("parametru invalid\n");
        return 1;
    }
    
    int count = 0;
    char line[256];
    
    int pipefd[2];
    if (pipe(pipefd) == -1) {
        perror("pipe");
        return 1;
    }
    
    int nrLinii = 0;
    int lung[10];
    
    while (fgets(line, 256, f) != NULL) {
        nrLinii++;
        lung[nrLinii] = strlen(line);
    }
    
    fseek(f, 0, SEEK_SET);
    
    for (int j = 1; j <= nrLinii; j++) {
        fgets(line, 256, f);
        
        pid_t pid = fork();

        if (pid == -1) {
            perror("parametru invalid\n");
            fclose(f);
            exit(1);
        } else if (pid == 0) {
            //copil
            int trimis = 0;
            for (int i = 0; i < lung[j]; i++) {
                if (isdigit(line[i])) {
                    trimis++;
                }
            }
            write(pipefd[1], &trimis, sizeof(int));
            fclose(f);
            exit(0);
        } else {
            //parinte
            int primit;
            int status;
            wait(&status);
            if (WIFEXITED(status)) {
                if (WEXITSTATUS(status) == 0) {
                    read(pipefd[0], &primit, sizeof(int));
                    count += primit;
                }
            }
        }
    }
    
    close(pipefd[0]);
    close(pipefd[1]);
    
    fclose(f);
    
    printf("%d\n", count);
    
    return 0;
}

---------------------



#!/bin/sh

suma=0

for nr in "$@"; do
    if [ "$nr" -eq "$nr" ]; then
        suma=$((suma + nr))
    else
        echo "parametru invalid">&2
        exit 1
    fi
done
echo "$suma"
exit 0
-----------

ceva modificare 
#!/bin/sh

if [ $# -lt 1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi
suma=0
for nr in "$@"; do
    if [ "$nr" -eq "$nr" ]; then
        suma=$((suma + nr))
    else
        echo "parametru invalid\n">&2
        exit 1
    fi
done

echo "$suma"
exit 0


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <ctype.h>

int main(int argc, char *argv[]) {
    int suma = 0;
//    int pipefd[2];
//    if (pipe(pipefd) == -1) {
//        perror("pipe");
//        return 1;
//    }
    for (int i = 1; i <= argc; i++) {
        pid_t pid = fork();
        if (pid == -1) {
            perror("fork\n");
            exit(1);
        } else if (pid == 0) {
            //copil
//            close(pipefd[0]);
            
            int ok = 0;
            for(int j = 0; j < strlen(argv[i]); j++) {
                if (!isdigit(argv[i][j]) && argv[i][j] != '-') {
                    ok = 1;
                }
            }
            if (ok == 1) {
                exit(1);
            } else {
                exit(2);
            }
            
        } else {
            //parinte
            int status;
            wait(&status);
            if (WIFEXITED(status)) {
                if (WEXITSTATUS(status) == 1) {
                    perror("parametru invalid\n");
                    return 1;
                } else if (WEXITSTATUS(status) == 2) {
                    int nr = atoi(argv[i]);
                    suma += nr;
                }
            }
        }
    }
    printf("%d\n", suma);
    return 0;
}
-----------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <ctype.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        perror("parametru invalid\n");
        return 1;
    }
    
    int suma = 0;
    
    for (int i = 1; i <= argc; i++) {
        pid_t pid = fork();
        if (pid == -1) {
            perror("parametru invalid\n");
            exit(1);
        } else if (pid == 0) {
            //copil
            int ok = 0;
            if (!isdigit(argv[i][0]) && argv[i][0] != '-') {
                ok = 1;
            }
            for (int j = 1; j < strlen(argv[i]); j++) {
                if (!isdigit(argv[i][j])) {
                    ok = 1;
                }
            }
            if (ok == 1) {
                exit(1);
            } else {
                exit(2);
            }
        } else {
            //parinte
            int status;
            wait(&status);
            if (WIFEXITED(status)) {
                if (WEXITSTATUS(status) == 1) {
                    perror("parametru invalid\n");
                    return 1;
                } else if (WEXITSTATUS(status) == 2) {
                    int nr = atoi(argv[i]);
                    suma += nr;
                }
            }
        }
    }
    
    printf("%d\n", suma);
    return 0;
}

---------------------


#!/bin/sh

if [ $# -ne 1 ]; then
    echo "parametru invalid">&2
    exit 1
fi

if [ ! -f $1 ]; then
    echo "parametru invalid">&2
    exit 1
fi

#grep -vc '^[1-9][0-9]{12}$' $1
grep -vc '^[1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$' $1

exit 0

#!/bin/bah



fis.txt

1090523123456
025481684521132168
2090523624351
2090523624362
abc123 732


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <ctype.h>

int main(int argc, char *argv[]) {
    char file[256];
    strcpy(file, argv[1]);
    
    FILE* f;
    
    f = fopen(file, "r");
    if (f == NULL) {
        fprintf(stderr, "parametru invalid\n");
        return 1;
    }
    
    int baieti = 0;
    int fete = 0;
    char line[256];
    
    int nrLinii = 0;
    
    while (fgets(line, 256, f) != NULL) {
        nrLinii++;
    }
    
    fseek(f, 0, SEEK_SET);
    
    for (int j = 1; j <= nrLinii; j++) {
        fgets(line, 256, f);
        pid_t pid = fork();
        if (pid == -1) {
            fprintf(stderr, "Fork error\n");
            exit(1);
        } else if (pid == 0) {
            int ok = 0;
            if (strlen(line) != 14) {                ok = 1;
            } else if (line[0] == '0') {
                ok = 1;
            } else {
                for (int i = 1; i < strlen(line) - 1; i++) {
                    if (line[i] < '0' || line[i] > '9' ) {
                        ok = 1;
                    }
                }
            }
            if (ok == 1) {
                exit(1);
            } else {
                int firstDigit = line[0] - '0';
                if (firstDigit % 2 == 0) {
                    exit(3);
                } else {
                    exit(4);
                }
            }
        } else {
            int status;
            wait(&status);

            if (WIFEXITED(status)) {
                if (WEXITSTATUS(status) == 3) {
                    fete += 1;
                } else if (WEXITSTATUS(status) == 4) {
                    baieti += 1;
                }
            }
        }
    }
    fclose(f);
    printf("fete:%d baieti:%d\n", fete, baieti);
    return 0;
}

---------------------

#!/bin/sh

if [ $# -ne 1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi

if [ ! -f $1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi

grep -vc '^[1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$' $1

exit 0


1090523123456
025481684521132168
2090523624351
2090523624362
abc123 732


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <ctype.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        perror("parametru invalid\n");
        return 1;
    }
    FILE* f;
    f = fopen(argv[1], "r");
    
    if (f == NULL) {
        perror("parametru invalid\n");
        return 1;
    }
    
    char line[256];
    int nrLinii = 0;
    while (fgets(line, 256, f) != NULL) {
        nrLinii++;
    }
    
    fseek(f, 0, SEEK_SET);
    
    int baieti = 0, fete = 0;
    
    for (int i = 1; i <= nrLinii; i++) {
        fgets(line, 256, f);
        pid_t pid = fork();
        if (pid == -1) {
            perror("parametru invalid\n");
            exit(1);
        } else if (pid == 0) {
            //copil
            int ok = 0;
            if (strlen(line) != 14) {
                ok = 1;
            } else if (line[0] == '0') {
                ok = 1;
            } else {
                printf("%s\n", line);
                for (int j = 0; j < strlen(line) - 1; j++) {
                    if (!isdigit(line[j])) {
                        ok = 1;
                        break;
                    }
                }
            }
            
            if (ok == 1) {
                exit(1);
            } else {
                int fs = line[0] - '0';
                if (fs % 2 == 0) {
                    exit(2);
                } else {
                    exit(3);
                }
            }
        } else {
            //parinte
            int status;
            wait(&status);
            if (WIFEXITED(status)) {
                if (WEXITSTATUS(status) == 2) {
                    fete++;
                } else if (WEXITSTATUS(status) == 3) {
                    baieti++;
                }
            }
        }
    }
    
    fclose(f);
    
    printf("%d %d\n", baieti, fete);
    
    return 0;
}


---------------------
#!/bin/sh

if [ $# -ne 1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi

if [ ! -f $1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi

#awk '{
#    num_cuvinte = 0
#    for (i = 1; i <= length($0); i++) {
#        if (substr($0, i, 1) == " ") {
#            num_cuvinte++
#        }
#    }
#    num_cuvinte++  # Adaugă unul pentru ultimul cuvânt de pe linie
#    print num_cuvinte }' $1

awk ' {print NF} ' $1



fis.txt

abc 123
fulga are mere
ana n-are pere


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <ctype.h>

int main(int argc, char *argv[]) {
    
    if (argc != 2) {
        perror("parametru invalid\n");
        return 1;
    }
    
    FILE* f;
    f = fopen(argv[1], "r");
    if (f == NULL) {
        perror("parametru invalid\n");
        return 1;
    }
    
    int nrLinii = 0;
    int lung[10];
    char line[256];
    
    while (fgets(line, 256, f) != NULL) {
        nrLinii++;
        lung[nrLinii] = strlen(line);
    }
    
    fseek(f, 0, SEEK_SET);
    for (int i = 1; i <= nrLinii; i++) {
        fgets(line, 256, f);

        pid_t pid = fork();
        if (pid == -1) {
            perror("parametru invalid\n");
            fclose(f);
            exit(1);
        } else if (pid == 0) {
            //copil
            int count = 0;
            for (int j = 1; j < lung[i]; j++) {
                if (line[j] == ' ') {
                    count++;
                }
            }
            count++;
            printf("%d\n", count);
            fclose(f);
            exit(0);
        } else {
            //parinte
            int status;
            wait(&status);
        }
    }
    
    fclose(f);
    
    return 0;
}




--------------------

#!/bin/sh

if [ $# -ne 1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi

if [ ! -f $1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi

sed -i -r  's/un/1/g; s/doi/2/g; s/trei/3/g' $1

exit 0





#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <ctype.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        perror("parametru invalid\n");
        return 1;
    }
    
    FILE* f;
    f = fopen(argv[1], "r");
    if (f == NULL) {
        perror("parametru invalid\n");
        return 1;
    }
    
    int count = 0;
    char line[256];
    
    int pipefd[2];
    if (pipe(pipefd) == -1) {
        perror("pipe");
        return 1;
    }
    
    int nrLinii = 0;
    int lung[10];
    
    while (fgets(line, 256, f) != NULL) {
        nrLinii++;
        lung[nrLinii] = strlen(line);
    }
    
    fseek(f, 0, SEEK_SET);
    
    for (int j = 1; j <= nrLinii; j++) {
        fgets(line, 256, f);
        
        pid_t pid = fork();

        if (pid == -1) {
            perror("parametru invalid\n");
            fclose(f);
            exit(1);
        } else if (pid == 0) {
            //copil
            int trimis = 0;
            for (int i = 0; i < lung[j]; i++) {
                if (isdigit(line[i])) {
                    trimis++;
                }
            }
            write(pipefd[1], &trimis, sizeof(int));
            fclose(f);
            exit(0);
        } else {
            //parinte
            int primit;
            int status;
            wait(&status);
            if (WIFEXITED(status)) {
                if (WEXITSTATUS(status) == 0) {
                    read(pipefd[0], &primit, sizeof(int));
                    count += primit;
                }
            }
        }
    }
    
    close(pipefd[0]);
    close(pipefd[1]);
    
    fclose(f);
    
    printf("%d\n", count);
    
    return 0;
}

--------------------

#!/bin/sh

if [ $# -ne 1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi

if [ ! -f $1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi

#awk '{
#    num_cuvinte = 0
#    for (i = 1; i <= length($0); i++) {
#        if (substr($0, i, 1) == " ") {
#            num_cuvinte++
#        }
#    }
#    num_cuvinte++  # Adaugă unul pentru ultimul cuvânt de pe linie
#    print num_cuvinte }' $1

awk ' {print NF} ' $1



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <ctype.h>

int main(int argc, char *argv[]) {
    
    if (argc != 2) {
        perror("parametru invalid\n");
        return 1;
    }
    
    FILE* f;
    f = fopen(argv[1], "r");
    if (f == NULL) {
        perror("parametru invalid\n");
        return 1;
    }
    
    int nrLinii = 0;
    int lung[10];
    char line[256];
    
    while (fgets(line, 256, f) != NULL) {
        nrLinii++;
        lung[nrLinii] = strlen(line);
    }
    
    fseek(f, 0, SEEK_SET);
    for (int i = 1; i <= nrLinii; i++) {
        fgets(line, 256, f);

        pid_t pid = fork();
        if (pid == -1) {
            perror("parametru invalid\n");
            fclose(f);
            exit(1);
        } else if (pid == 0) {
            //copil
            int count = 0;
            for (int j = 1; j < lung[i]; j++) {
                if (line[j] == ' ') {
                    count++;
                }
            }
            count++;
            printf("%d\n", count);
            fclose(f);
            exit(0);
        } else {
            //parinte
            int status;
            wait(&status);
        }
    }
    
    fclose(f);
    
    return 0;
}


--------------------
#!/bin/sh

if [ $# -lt 1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi
suma=0
for nr in "$@"; do
    if [ "$nr" -eq "$nr" ]; then
        suma=$((suma + nr))
    else
        echo "parametru invalid\n">&2
        exit 1
    fi
done

echo "$suma"
exit 0


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <ctype.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        perror("parametru invalid\n");
        return 1;
    }
    
    int suma = 0;
    
    for (int i = 1; i <= argc; i++) {
        pid_t pid = fork();
        if (pid == -1) {
            perror("parametru invalid\n");
            exit(1);
        } else if (pid == 0) {
            //copil
            int ok = 0;
            if (!isdigit(argv[i][0]) && argv[i][0] != '-') {
                ok = 1;
            }
            for (int j = 1; j < strlen(argv[i]); j++) {
                if (!isdigit(argv[i][j])) {
                    ok = 1;
                }
            }
            if (ok == 1) {
                exit(1);
            } else {
                exit(2);
            }
        } else {
            //parinte
            int status;
            wait(&status);
            if (WIFEXITED(status)) {
                if (WEXITSTATUS(status) == 1) {
                    perror("parametru invalid\n");
                    return 1;
                } else if (WEXITSTATUS(status) == 2) {
                    int nr = atoi(argv[i]);
                    suma += nr;
                }
            }
        }
    }
    
    printf("%d\n", suma);
    return 0;
}
--------------------

#!/bin/sh

if [ $# -ne 1 ]; then
    echo "parametru invalid">&2
    exit 1
fi

if [ ! -f $1 ]; then
    echo "parametru invalid">&2
    exit 1
fi

#grep -vc '^[1-9][0-9]{12}$' $1
grep -vc '^[1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$' $1

exit 0


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <ctype.h>

int main(int argc, char *argv[]) {
    char file[256];
    strcpy(file, argv[1]);
    
    FILE* f;
    
    f = fopen(file, "r");
    if (f == NULL) {
        fprintf(stderr, "parametru invalid\n");
        return 1;
    }
    
    int baieti = 0;
    int fete = 0;
    char line[256];
    
    int nrLinii = 0;
    
    while (fgets(line, 256, f) != NULL) {
        nrLinii++;
    }
    
    fseek(f, 0, SEEK_SET);
    
    for (int j = 1; j <= nrLinii; j++) {
        fgets(line, 256, f);
        pid_t pid = fork();
        if (pid == -1) {
            fprintf(stderr, "Fork error\n");
            exit(1);
        } else if (pid == 0) {
            int ok = 0;
            if (strlen(line) != 14) {                ok = 1;
            } else if (line[0] == '0') {
                ok = 1;
            } else {
                for (int i = 1; i < strlen(line) - 1; i++) {
                    if (line[i] < '0' || line[i] > '9' ) {
                        ok = 1;
                    }
                }
            }
            if (ok == 1) {
                exit(1);
            } else {
                int firstDigit = line[0] - '0';
                if (firstDigit % 2 == 0) {
                    exit(3);
                } else {
                    exit(4);
                }
            }
        } else {
            int status;
            wait(&status);

            if (WIFEXITED(status)) {
                if (WEXITSTATUS(status) == 3) {
                    fete += 1;
                } else if (WEXITSTATUS(status) == 4) {
                    baieti += 1;
                }
            }
        }
    }
    fclose(f);
    printf("fete:%d baieti:%d\n", fete, baieti);
    return 0;
}



--------------------

#!/bin/sh

if [ $# -ne 1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi

if [ ! -f $1 ]; then
    echo "parametru invalid\n">&2
    exit 1
fi

awk ' { puncte=0; puncte+=3*$1; puncte+=$3; print puncte } ' "$1"

exit 0



fis.txt
3 12 47
1 0 1
0 0 0
1 10 0
0 0 1




in c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        perror("parametru invalid\n");
        return 1;
    }
    
    FILE* f;
    f = fopen(argv[1], "r");
    if (f == NULL) {
        perror("parametru invalid\n");
        return 1;
    }
    
    int pipefd[2];
    if (pipe(pipefd) == -1) {
        perror("parametru invalid\n");
        return 1;
    }
    
    char line[256];
    int nrLinii = 0;
    int lung[10];
    while (fgets(line, 256, f) != NULL) {
        nrLinii++;
        lung[nrLinii] = strlen(line);
    }
    
    fseek(f, 0, SEEK_SET);
    
    for (int i = 1; i <= nrLinii; i++) {
        fgets(line, 256, f);
        
        pid_t pid = fork();
        
        if (pid == -1) {
            perror("parametru invalid\n");
            exit(1);
        } else if (pid == 0) {
            //copil
            
            int puncte = 0;
            char* sep = " ";
            char* token = strtok(line, sep);
            
            int nr = atoi(token);
            puncte += 3*nr;
            
            token = strtok(NULL, " ");
            token = strtok(NULL, " ");
            nr = atoi(token);
            puncte += nr;
            
            printf("%d\n", puncte);
            
            fclose(f);
            exit(0);
        } else {
            //parinte
            
            int status;
            wait(&status);
        }
    }
    
    fclose(f);
    
    return 0;
}




lab03 pr 10

#!/bin/sh

# directorul cu fișierele de transport
dir=$1

# verificam daca exista doar un parametru
if [ $# -ne 1 ]; then
    echo "parametru invalid">&2
    exit 1
# verificam daca parametrul dat este un director
elif [ ! -d $dir ]; then
        echo "parametru invalid">&2
        exit 1
fi

# parcurgem fiecare fișier
for file in $dir/*; do
    # verificam daca fisierul este text
    if [ -f $file ]; then
        # verificăm dacă primul rând conține "IN"
        first_line=$(head -n 1 "$file")
        if [ "$first_line" = "IN" ]; then
        # afișăm numele fișierului
            echo "$(basename "$file")"
        fi
    fi
done | sort




lab4 pr 10

#!/bin/sh

# verificam daca exista doar un parametru
if [ $# -ne 2 ]; then
    echo "parametru invalid">&2
    exit 1
fi
    
# directorul cu fișierele de transport
dir=$1
fis=$2

# verificam daca primul parametru dat este un director
if [ ! -d $dir ]; then
        #echo "parametru invalid">&2
        exit 1
fi

# verificam daca al doilea parametru se afla in directorul dat ca prim parametru
if [ ! -f $dir/$fis ]; then
    echo "parametru invalid">&2
    exit 1
fi

# verificam formatul cerut
grep -E '^IN|OUT$|^([a-zA-Z]+( [a-zA-Z]+)*)\,[0-9]+$' -i -- "$dir/$fis" > tmpfile && mv tmpfile "$dir/$fis"




tot pr 10

#!/bin/sh

dir=$1
fis=$2
old=$3
new=$4

sed -i -r "s/$old/$new/g" "$dir/$fis"




if grep -q "^$product," "$dir/depozit.csv"; then
    quantityInFile=$(grep "^$product," "$dir/depozit.csv" | cut -d ',' -f2)
    new=$((quantityInFile + quantity))
    sed -i -r "s/$product,$quantityInFile/$product,$new/" "$dir/depozit.csv"
else
    echo "$product,$quantity" >> "$dir/depozit.csv"
fi











lab5 pr10
#!/bin/sh

dir=$1

# verificam daca primul parametru dat este un director
if [ ! -d $dir ]; then
    exit 1
fi

# verificam tot ce este in director
for file in "$dir"/*; do
    # verificam sa fie fisier
    if [ -f "$file" ]; then
        # salvam suma produselor din fisier
        total=$(awk -F ',' 'NR>1 {sum += $2} END {print sum}' "$file")
        # afisam numele fisierului + suma totala
        echo "$(basename "$file") $total"
    fi
done | sort





lab6 pr 10

#!/bin/sh

# verificam ca exista cel putin 2 parametri
if [ $# -lt 2 ]; then
  exit 1
fi

dir=$1

# verificam daca primul parametru dat este un director
if [ ! -d "$dir" ]; then
    exit 1
fi

# verificam daca exista depozit.csv se afla in directorul dat
if [ ! -f "$dir/depozit.csv" ]; then
    exit 1
fi

# parcurgem toti parametri dati
for file in "${@:2}"; do
    # verificam daca parametrul este fisier
    if [ ! -f "$dir/$file" ]; then
        exit 1
    fi
    
    tip=$(head -n 1 "$dir/$file")
    # verificam tipul fisierului de transport
    if [ "$tip" != "IN" ] && [ "$tip" != "OUT" ]; then
        exit 1
    fi

    # parcurgem fisierul linie cu linie
    while read -r line; do
        # verificam ca linia respectiva sa nu fie "IN" sau "OUT"
        if [ "$line" != "IN" ] && [ "$line" != "OUT" ]; then
            product=$(echo "$line" | cut -d ',' -f 1)
            quantity=$(echo "$line" | cut -d ',' -f 2)
            
            if [ "$tip" = "IN" ]; then
                if grep -q "^$product," "$dir/depozit.csv"; then
                    quantityInFile=$(grep "^$product," "$dir/depozit.csv" | cut -d ','  -f2)
                    new=$((quantityInFile + quantity))
                    sed -i -r "s/$product,$quantityInFile/$product,$new/"   "$dir/depozit.csv"
                else
                echo "$product,$quantity" >> "$dir/depozit.csv"
                fi
            else
                quantityInFile=$(grep "^$product," "$dir/depozit.csv" | cut -d ',' -f2)
                new=$((quantityInFile - quantity))
        
                # Verificam daca exista suficient stoc in depozit
                if [ "$new" -lt 0 ]; then
                    exit 1
                fi
                sed -i -r "s/$product,$quantityInFile/$product,$new/" "$dir/depozit.csv"
            fi
        fi
    done < "$dir/$file" | tail -n +2
done












Pentru o lista de nume de fisiere data si pentru un director dat, sa se afiseze pentru fiecare nume de fisier toate subdirectoarele în care acesta apare. Sa se afiseze subdirectoarele în ordinea descrescatoare a datei crearii fisierului.


director=$1
shift 1
for f in $*
do
find $director -name $f -exec ls -1rt "{}" +
done







1
extrase PB SO
#Problema cu owner
first="$1"
list_of_users=$(cut -d: -f1 /etc/passwd)
current_user="$USER"
#echo $current_user
#l=$(grep "$1" /etc/passwd)
#echo $list_of_users
for user in $list_of_users
do 
	if [ "$user" == "$first" ];
	then
		sudo chown -R $current_user /home/ioana
	else echo " "
	fi  
done






2
#Sa se adauge in fata fiecarei litere mici cuvantul indicat ca
#prim parametru. Fisierele tratate sunt ceilalti parametrii din
#linia de comanda.
first=$1
for file in "${@:2}"
do
sed -r 's/[a-z]/'$first' &/g' $file	
done



2 a 

#Pentru o lista de servere date ca parametri in linia de comanda
#se cere sa se afiseze daca sunt accesibile sau nu
urls=$@
COUNT=1
for url in $urls
do
	value=$(ping -c $COUNT $url | grep 'received' | awk -F',' '{ print $2 }' | awk '{ print $1 }')
	if [[ $value -eq "0" ]]; then 
		echo "$url IS DOWN"
	else echo "$url EXIST"
	fi
	
	#if ping -c 3 $url 
	#then
	#	echo "$url EXIST"
	#else
	#	echo "$url NOT EXIST"
	#fi
done





3


first=$1
_l="/etc/login.defs"
_p="/etc/passwd"

l=$(grep "^UID_MIN" $_l)
l1=$(grep "^UID_MAX" $_l)

echo "---Sysem User Accounts---"

users=$(awk -F':' '{print $1}' "$_p")
for user in $users
do
 if [ "$user" == "$first" ]
 then
 fi
done






4

#awk -F ":"
BEGIN{
 for (i=1; i< ARGC; i++)
 { if ( i % 2 == 0){
    command="tail -r ARGC[i] | awk '{for (j=NF; j>0; j--) print $j }' ARGC[i]";
    command |getline;
    }  
   else{ 
    command="awk '{for (j = 1; j<=NF; j++_ print $j}' ARGC[i]";
    command |getline 
 }
 } 
}






5

#Sa se afiseze continutul oricator fisiere dupa cum urmeaza
#primul fisier asa cum este, iar fisierul urmator cu cuvintele
#in ordine inversa serparate prin :)

for file in "${@:1}"
do
#	if [[ file  % 2 == '0']]
#	then
#	command=$(
	tail -r $file | awk '{for (i=NF;i>0;i--) print $i}' $file
#	fi
done
		




server.py

import socket
s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
s.bind(("192.168.56.1",5555))
buff,addr=s.recvfrom(10)
print buff
s.sendto("hello",addr)



client.py
import socket
s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
s.sendto("hey",("127.0.0.1",5555))
print s.recvfrom(10)




client1.py
from socket import *
host='localhost'
port=52000
sock=socket()
sock.connect((host,port))
while True:
 data=sock.recv(1024)
 print data
 sock.send('Hi! I am client')
 
sock.close()










server1.py

from socket import *
from thread import *
host= 'localhost'
port=52000
sock=socket()
sock.bind((host,port))
sock.listen(2)

def clientthread(conn):
 while True:
  conn.send('Hi! I am server\n')
  data=conn.recv(1024)
  print data
  
 while True:
  conn, addr=sock.accept()
  start_new_thread(clientthread,(conn))
  
conn.close()
sock.close()



cuvinte.txt
b  BBB AAAA  a  l  m 
LLDSSS a
x PPP K t
M







cuvinte1.txt

CUVINTE AAAAaAAA BbBBB
d
Al   p  OOO
E akx U








exemplu.txt
this is main example
alt exemplu aici
maine nu mai ploua


fis.txt

ds hgh aaa
1 2 3
asss dfdf





fisier.txt
ana are mere
:)afara :)ploua 
:)pisica :)nu :)vrea :)sa :)stea :)in :)casa






















#!/bin/bash

# [ ! -f parametru ] - verifica daca fisierul nu exista
# [ ! -d parametru ] - verifica daca directorul nu exista 
# >&2 trimite eroarea in stderr
if [ ! -f "$1" ]; then
	echo "parametru invalid" >&2
	exit 0
fi

# read line citeste din fisierul "done < $1"
while read line; do
	# cut -d  "separator", -f 4 (de ex cuv1,cuv2,cuv3,cuv4 => cuv4)
	capacitate_cilindrica=$(echo $line | cut -d, -f 4)
	# cut -d "separator", -f 3 (de ex cuv1,cuv2,cuv3,cuv4 => cuv4)
	cai_putere=$(echo $line | cut -d, -f 3)
	# let permite calculul si atribuirea valorii unei expresii matematice la o variabila
	let raport=$capacitate_cilindrica/$cai_putere
	# afisam rezultatul
	echo $raport
# < $1 arata din ce fisier se citeste (fisierul dat in parametrul 1)
done < $1






#!/bin/bash

if [ ! -f "$1" ]; then
	echo "parametru invalid" >&2
	exit 0
fi

if ! echo "$2" | grep -Eq '^[[:alpha:][:space:]]+$'; then
	echo "parametru invalid" >&2
	exit 0
fi

no_models=$(grep "^$2," "$1" | cut -d ',' -f 2 | sort | uniq | wc -l)

echo "$no_models"







#!/bin/bash

if [ ! -f "$1" ]; then
	echo "parametru invalid" >&2
	exit 0
fi

if [[ ! "$4" =~ ^[0-9]+$ ]]; then
	echo "parametru invalid" >&2
	exit 0
fi

sed -i "/^$2,$3,/s/,[0-9]\+/,${4}/" "$1"





#!/bin/bash

if [ ! -f "$1" ]; then
	echo "parametru invalid" >&2
	exit 0
fi

awk -F ',' '{
  producer=$1
  producerCount[producer]++
  powerSum[producer]+=$3
  capacitySum[producer]+=$4
} END {
  for (producer in producerCount) {
    powerAvg=int(powerSum[producer] / producerCount[producer])
    capacityAvg=int(capacitySum[producer] / producerCount[producer])
    
    printf("%s,%d,%d,%d\n", producer, producerCount[producer], powerAvg, capacityAvg)
  }
}' $1 | sort





#!/bin/bash

if [ ! -f "$1" ]; then
	echo "parametru invalid" >&2
	exit 0
fi

if [ ! -f "$2" ]; then
	echo "parametru invalid" >&2
	exit 0
fi

while read line; do
	marca=$(echo $line | cut -d, -f 1)
	model=$(echo $line | cut -d, -f 2)
	cai_putere=$(echo $line | cut -d, -f 3)
	capacitate_cilindrica=$(echo $line | cut -d, -f 4)
	dotari=$(echo $line | cut -d, -f 5)
	impozit=$(awk -F ',' -v cap="$capacitate_cilindrica" '{ if(cap >= $1 && cap <= $2) print int(cap/200*$3) }' $2)
	echo "$marca,$model,$cai_putere,$capacitate_cilindrica,$dotari,$impozit" >> tmp.txt
done < $1

mv tmp.txt $1
rm tmp.txt


----------------------------

CCCCCCCCCCCCCCCCCCCCCCCC
C!!!!!!!1



lab 10 c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main(int argc, char *argv[]) {
    char *dir = argv[1];
    
    for (int i = 2; i < argc; i++) {
        char file[256];
        strcpy(file, dir);
        strcat(file, "/");
        strcat(file, argv[i]);
        
        FILE* f;
        char line[256];
        
        f = fopen(file, "r");
        
        if (f == NULL) {
            fprintf(stderr, "parametru invalid\n");
            return 1;
        }
        
        int count = 0;
        
        while (fgets(line, 256, f) != NULL) {
            count = count + 1;
        }
        
        count = count - 1;
        
        fprintf(stdout, "%d\n", count);
        
        fclose(f);
    }
    return 0;
}




#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>


int main(int argc, char *argv[]) {
    char *dir = argv[1];
    
    for (int i = 2; i < argc; i++) {
        char file[256];
        strcpy(file, dir);
        strcat(file, "/");
        strcat(file, argv[i]);
        
        FILE* f;
        char line[256];
        
        int pid = fork();
        
        if (pid==0) {
            //copil
            f = fopen(file, "r");
            
            if (f == NULL) {
                fprintf(stderr, "parametru invalid\n");
                exit(1);
            }
            
            int count = 0;
            
            while (fgets(line, 256, f) != NULL) {
                count = count + 1;
            }
            
            count = count - 1;
            
            fprintf(stdout, "%d\n", count);
            
            fclose(f);
            exit(0);
        }
        int status;
        wait(&status);
        if (WIFEXITED(status) && WEXITSTATUS(status)) {
            return 1;
        }
    }
    return 0;
}








#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

// Să se scrie un program C care creează un proces copil cu care 
// comunică prin pipe.
// Procesul părinte citeşte de la tastatură un număr natural şi îl
// trimite prin pipe procesului copil,
// iar procesul copil verifică şi afişează dacă acest număr este par 
// sau impar.

int main(int argc, char* argv[]) {
	int fdp[2];
	if(pipe(fdp) == -1) {
		fprintf(stderr, "eroare la pipe()");
	}
	pid_t pid = fork();
	if(pid < 0) {
		fprintf(stderr, "eroare la fork()");
		exit(1);
	} else if(pid == 0) {
		close(fdp[1]);
		int number;
		read(fdp[0],&number,sizeof(int));
		if(number % 2 == 0) {
			printf("Este par!\n");
		}
		else {
			printf("Este impar!\n");
		}
		close(fdp[0]);
	} else {
		close(fdp[0]);
		int number;
		scanf("%d", &number);
		write(fdp[1],&number,sizeof(int));
		close(fdp[1]);
	}
	return 0;
}






#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

#define NUME_FIFO "pipe.fifo"

// Să se scrie un program C care creează un proces copil cu care 
// comunică prin pipe.
// Procesul părinte citeşte de la tastatură un număr natural şi îl 
// trimite prin pipe procesului copil,
// iar procesul copil verifică şi afişează dacă acest număr este 
// prim.

int main(int argc, char* argv[]) {
	int status = mkfifo(NUME_FIFO,0666);
	if(status == -1) {
		fprintf(stderr, "eroare la mkfifo()");
		return 1;
	}
	pid_t pid = fork();
	if(pid < 0) {
		fprintf(stderr, "eroare la fork()");
		return 1;
	}
	else if(pid == 0) {
		int fd = open(NUME_FIFO, O_RDONLY);
		if(fd == -1) {
			fprintf(stderr, "eroare la open()");
			return 1;
		}
		int number;
		read(fd, &number, sizeof(int));
		int d = 2, ok = 1;
		while(d <= number /2) {
			if(number % d == 0) {
				ok = 0;
				number = number / d;
			}
			d++;
		}
		if(ok == 1) {
			printf("este prim\n");
		}
		else {
			printf("nu este prim\n");
		}
	} else {
		int number;
		scanf("%d", &number);
		int fd = open(NUME_FIFO, O_WRONLY);
		if(fd == -1) {
			fprintf(stderr, "eroare la open()");
			return 1;
		}
		write(fd, &number, sizeof(int));
		close(fd);
	}
	unlink(NUME_FIFO);
	return 0;
}




#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>

// SÄƒ se scrie un program C care creeazÄƒ un proces copil cu care 
// comunicÄƒ prin pipe.
// Procesul pÄƒrinte citeÅŸte de la tastaturÄƒ douÄƒ numere Ã®ntregi pe 
// care le trimite prin pipe procesului copil,
// iar procesul copil returneazÄƒ prin pipe suma lor.

int main(int argc, char* argv[]) {
	int fdp[2];
	if(pipe(fdp) == -1) {
		fprintf(stderr, "eroare la pipe()");
		return 1;
	}
	pid_t pid = fork();
	if(pid == -1) { // eroare
		fprintf(stderr, "eroare la fork()");
		exit(1);
	} else if(pid == 0) { // c8chil
		int number1, number2;
		read(fdp[0],&number1,sizeof(int));
		read(fdp[0],&number2,sizeof(int));
		close(fdp[0]);
		int sum = number1 + number2;
		write(fdp[1],&sum,sizeof(int));
		close(fdp[1]);
	} else { // parent
		int number1, number2;
		scanf("%d", &number1);
		scanf("%d", &number2);
		write(fdp[1],&number1,sizeof(int));
		write(fdp[1],&number2,sizeof(int));
		close(fdp[1]); // 1 write
		int status;
		wait(&status);
		int sum;
		read(fdp[0],&sum,sizeof(int));
		printf("suma este %d\n", sum);
		close(fdp[0]); // 0 read
	}
	return 0;
}




#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 300

int main(int argc, char *argv[]) {
    FILE *file = fopen(argv[1], "r");
    if (file == NULL) {
        fprintf(stderr, "parametru invalid");
        return 0;
    }
    
    char marca_max[100];
    char model_max[100];
    int cai_max = 0;
    char line[MAX_LINE_LENGTH];
    while (fgets(line, MAX_LINE_LENGTH, file)) {
        char *marca = strtok(line, ",");
        char *model = strtok(NULL, ",");
        int cai = atoi(strtok(NULL, ","));

        if (cai > cai_max) {
            strcpy(marca_max, marca);
            strcpy(model_max, model);
            cai_max = cai;
        }
    }
    printf("%s %s\n", marca_max, model_max);

    fclose(file);
    return 0;
}


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 300

char marca_max[100];
char model_max[100];
int cai_max = 0;

int main(int argc, char *argv[]) {
    FILE *file = fopen(argv[1], "r");
    if (file == NULL) {
        fprintf(stderr, "parametru invalid");
        return 0;
    }
    char line[MAX_LINE_LENGTH];
    while (fgets(line, MAX_LINE_LENGTH, file)) {
    	pid_t pid = fork();
    	if(pid < 0) { // eroare
    		fprintf(stderr, "eroare la fork()");
    	}
    	else if(pid == 0) { // copil
       		char *marca = strtok(line, ",");
        	char *model = strtok(NULL, ",");
        	int cai = atoi(strtok(NULL, ","));
        	if (cai > cai_max) {
            		strcpy(marca_max, marca);
            		strcpy(model_max, model);
            		cai_max = cai;
        	}
        }
        else { // parinte
        	int status;
        	wait(&status);
        	exit(0);
        }
    }
    printf("%s %s\n", marca_max, model_max);

    fclose(file);
    return 0;
}



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>

#define MAX_LINE_LENGTH 300

char model_max[100];
char marca_max[100];
int cai_max;

int main(int argc, char *argv[]) {
    FILE *file = fopen(argv[1], "r");
    if (file == NULL) {
        fprintf(stderr, "parametru invalid");
        return 0;
    }
    char line[MAX_LINE_LENGTH];
    while (fgets(line, MAX_LINE_LENGTH, file)) {
    	int fdp[2];
    	if (pipe(fdp) == -1) {
        	fprintf(stderr, "eroare la pipe()");
        	return 1;
    	}
    	pid_t pid = fork();
    	if(pid < 0) { // eroare
    		fprintf(stderr, "eroare la fork()");
    		return 1;
    	}
    	else if(pid == 0) { // copil
    		close(fdp[0]);
    		char *marca = strtok(line, ",");
        	char *model = strtok(NULL, ",");
        	int cai = atoi(strtok(NULL, ","));
    		int n = strlen(marca);
        	write(fdp[1],&n,sizeof(int));
        	int m = strlen(model);
        	write(fdp[1],&m,sizeof(int));
        	write(fdp[1],marca,n*sizeof(char));
        	write(fdp[1],model,m*sizeof(char));
                write(fdp[1],&cai,sizeof(int));
        	close(fdp[1]);
        	exit(0);
        }

        else { // parinte
        	close(fdp[1]);
    		int n,m;
    		read(fdp[0],&n,sizeof(int));
    		read(fdp[0],&m,sizeof(int));
    		char *marca = (char*)malloc((n+1)*sizeof(char));
    		char *model = (char*)malloc((m+1)*sizeof(char));
    		read(fdp[0],marca,n);
    		marca[n] = '\0';
    		read(fdp[0],model,m);
    		model[m] = '\0';
    		int cai;
    		read(fdp[0],&cai,sizeof(int));
    		close(fdp[0]);
    		if(cai > cai_max) {
    			cai_max = cai;
    			strcpy(marca_max, marca);
    			strcpy(model_max, model);
    		}
        }
    }
    int status;
    while(wait(&status) > 0);
    printf("%s %s\n", marca_max, model_max);
    fclose(file);
    return 0;

}





#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <fcntl.h>

#define MAX_LINE_LENGTH 300
#define NUME_FIFO "lab11.fifo"

char model_max[100];
char marca_max[100];
int cai_max;

int main(int argc, char *argv[]) {
    FILE *file = fopen(argv[1], "r");
    if (file == NULL) {
        fprintf(stderr, "parametru invalid");
        return 0;
    }
    char line[MAX_LINE_LENGTH];
    while (fgets(line, MAX_LINE_LENGTH, file)) {
    	int status = mkfifo(NUME_FIFO,0666);
    	if(status == -1) {
    		fprintf(stderr, "eroare la mkfifo()");
    	}
    	pid_t pid = fork();
    	if(pid < 0) { // eroare
    		fprintf(stderr, "eroare la fork()");
    		return 1;
    	}
    	else if(pid == 0) { // copil
    		int fd = open(NUME_FIFO, O_WRONLY);
    		char *marca = strtok(line, ",");
        	char *model = strtok(NULL, ",");
        	int cai = atoi(strtok(NULL, ","));
    		int n = strlen(marca);
        	write(fd,&n,sizeof(int));
        	int m = strlen(model);
        	write(fd,&m,sizeof(int));
        	write(fd,marca,n*sizeof(char));
        	write(fd,model,m*sizeof(char));
                write(fd,&cai,sizeof(int));
                close(fd);
                fclose(file);
        	exit(0);
        }

        else { // parinte
        	int fd = open(NUME_FIFO, O_RDONLY);
    		int n,m;
    		read(fd,&n,sizeof(int));
    		read(fd,&m,sizeof(int));
    		char *marca = (char*)malloc((n+1)*sizeof(char));
    		char *model = (char*)malloc((m+1)*sizeof(char));
    		read(fd,marca,n);
    		marca[n] = '\0';
    		read(fd,model,m);
    		model[m] = '\0';
    		int cai;
    		read(fd,&cai,sizeof(int));
    		if(cai > cai_max) {
    			cai_max = cai;
    			strcpy(marca_max, marca);
    			strcpy(model_max, model);
    		}
        }
    }
    int status;
    while(wait(&status) > 0);
    printf("%s %s\n", marca_max, model_max);
    unlink(NUME_FIFO);
    return 0;

}







-------------- VECHIIIIIIIIIIIIIII



 
Username: sdar2590
Password: ZTM3Nz^iYTc3




. - ne potriveste orice caracter

.* - si liniile cu caractere si liniile goale

? 0-1 

man test
-q nu ne afiseaza nimic
dar seteaza codul de retur la true


if [ grep inseamna test grep

-ne not  equal

> suprascrie fisierul == redirectare
>>  = append si adauga la final si pastreaza ce a fost inainte

wc -l wordd count -l

 



cp fulga.txt /.so4

sed "y/a/A/" fulga.txt
sed "y/ab/AB/" fulga.txt
sed "y/ab/BA/" fulga.txt a-B b-A


sed -r "s/[a-zA-Z]+/000/" fulga.txt
sed -r "s/[a-zA-Z]+/000/2" fulga.txt
sed -r "s/[a-zA-Z]+/000/g" fulga.txt

vrem sa inlocuim primul cuvant cu cifra 1 - si al doilea cu cifra 2

sed -r "s/^([a-z]+)[^a-z]([a-z]+)/1 2/g" fulga.txt


daca vrem sa pastram si - liniuta




intel,15,16,windows,nvidia,ssd,lenovo



-> lenovo space intel space i5..    (space 16_windows_ssd_nvidia)
ultima pozitie vine prima iar restul sunt separate prin spatiu 

 sed -r 's/^([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)$/ \7 \1 \2 \3 \4 \5 \6 /g' sisteme.txt      ce inseamna -r  

s/ = substitute 
\7 \1   spatiu ca am zis ca vrem cu spatiu intre ele

([^,]+) - cautam orice care nu e virgula


se pun ' ' sau " " ?????




sau
sed "y/,/space" file | sed -r "s/(.*)space(^_ sau .*)$/\2 \1

separam cu un regex marca lenove de la final
si cu unul toata bucata dinainte restul de 6 chestii 



 Lenovo Intel i5 16 Windows Nvidia SSD

 Apple Mac M1 8 MacOS Integrata SSD

 Asus Intel i7 16 Windows Nvidia SSD

 Acer AMD Ryzen7 32 Linux AMD SSD

 Lenovo AMD Ryzen5 8 Windows Integrata SSD

 Lenovo AMD Ryzen5 16 Windoes Nvidia SSD

 Lenovo Intel i7 16 Windows Nvidia SSD

 Asus AMD Ryzen7 16 Windows Nvidia SSD

 Lenovo Intel i5 16 Windows Integrata SSD

Intel,i5,8,Windows,,Nvidia,SSD,Lenovo

 Lenovo AMD Ryzen3 8 Windoes AMD SSD

 Asus Intel i3 16 Linux Nvidia SSD

 HP Intel i5 16 Windows Integrata SSD

 Dell Intel i5 16 Windows Integrata SSD

 Lenovo Intel i7 16 Windows Integrata SSD

 Dell Intel i5 16 Windows Nvidia SSD
[sdar2590@linux ~]$ ^[[200~sed -e 'y/aeiouAEIOU/AEIOUaeiou/' input.txt
-bash: $'\E[200~sed': command not found
[sdar2590@linux ~]$ ~sed -E 'y/aeiouAEIOU/AEIOUaeiou/' angajati.txt
-bash: ~sed: command not found
[sdar2590@linux ~]$ sed -E 'y/aeiouAEIOU/AEIOUaeiou/' angajati.txt
iOnEl POpEscU 10/3/1961:COlInEI,2,ClUj-NApOcA:0740-123456 3500

VAsIlE GEOrgEscU 5/10/1942:PIAtA REpUblIcII,35,ClUj-NApOcA:0722-654321 2850

alExAndrU iOnEscU 3/7/1971:alEEA BIblIOtEcII,10,ClUj-NApOcA:0721-124536 3875

TUdOr alExAndrEscU 2/5/1963:alEEA BAIsOArA,53,ClUj-NApOcA:0742-235641 2355

VIctOr BAcIU 25/9/1968:erOIlOr,105,FlOrEstI:0723-162453 4560

HOrAtIU VAsIlEscU 23/4/1965:PIAtA MArAstI,13,ClUj-NApOcA:0741-485769 37005

adrIAn PIntEA 11/8/1957:LAcrImIOArElOr,22,ClUj-NApOcA:0742-258369 1942

MIrcEA DIAcOnU 6/11/1946:PrIEtEnIEI,7,SOmEsEnI:0744-147258 2565

ovIdIU MOldOvAn 17/1/1942:almAsUlUI,65,ClUj-NApOcA:0722-123789 1968

PUIU CAlInEscU 21/6/1920:PItEstI,88,ClUj-NApOcA:0723-452163 1971

olgA TUdOrAchE 24/1/1932:FlOrIlOr,41,FlOrEstI:0744-458712 1942

StElA enAchE 28/2/1952:SIndIcAtElOr,75,ClUj-NApOcA:0745-563214 1946

RAdU BElIgAn 8/4/1949:ZAmbIlEI,98,SOmEsEnI:0744-852369 1957

octAvIAn COtEscU 17/12/1954:StEjArUlUI,68,FlOrEstI:0745-789456 32150

SIlvIU achIm 19/10/1936:TUdOr VlAdImIrEscU,18,ClUj-NApOcA:0726-369147 1932

TOmA VOIcU 27/5/1948:SpOrtUlUI,43,FlOrEstI:0740-987125 1949

ilArIOn CIObAnU 4/7/1931:XEnOpOl,32,ClUj-NApOcA:0728-456987 1946

GhEOrghE DInIcA 30/2/1934:VrAbIIlOr,6,SOmEsEnI:0740-256314 1963

LIvIU CIUlEI 26/9/1947:MArAmUrEsUlUI,43,ClUj-NApOcA:0741-785469 1920

VIctOr REbEngIUc 31/3/1931:PArIs,9,ClUj-NApOcA:0723-254136 1954

VlAd NIcOlAEscU 13/3/1965:oAsUlUI,15,ClUj-NApOcA:0745-741289 1949





1'. sa se stearga cuvintele ce contin cifre

fisierul arata asa  sunt separate cuvintele prin spatiu


ex1.txt
123 ana banana 232
929 aaaa
hds jjjj ssssssss 
90 9 9 92
99 aaaaa bbbb ccccc

 


problema 1 sa se stearga toate cuvintele care contin cel putin o cifra din fisierul dat ca parametru. rezultatul va fi afisat la iesirea standard (cuvintele contin doar litere sau cifre)
sed -E 's/[0-9]+//g' ex1.txt       --> substitute cifrele cu nimic

 ana banana
 aaaa
hds jjjj ssssssss



sed -E 's/[0-9]+//' ex1.txt      --- daca nu pun g imi ia doar prima aparitie unde apar cifre pe fiecare linie
 ana banana 232
 aaaa
hds jjjj ssssssss
 9 9 92
 aaaaa bbbb ccccc




$# = nr de argumente
shift am scos argumentul de filename




ex2.txt
123 ana banana 232
929 aaaa primavara12000
hds jjjj ssssssss 88
90 9 9 92 1ab2c3
floare12 99 aaaaa bbbb ccccc



de sters de aici toate cuvintele formate doar din cifre, dar si cuvintele care contin cifre printre litere




problema 2 sa se inlocuiasca toate vocalele mici din fisierul dat ca parametru cu litere mari si viceversa. rezultatul va fi afisat la iesirea standard
sed -E 'y/aeiouAEIOU/AEIOUaeiou/d' angajati.txt


problema 3 sa se stearga toate aparitiile cuvintelor date ca parametri din fisierul care este dat ca prim parametru. fisierul va fi modificat si nu se va afisa nimic la iesirea standard











---------------------------------------------------------------------------

script ce valideaza numere introduse ca parametri

---------------------------------------------------------------------------

tema lab 3

06:00
255.255.255.255        ([0-9]+\.){3}[0-9]+    +=cel putin o data / o cifra
1234567890123
33.12.1997  [0-9]{2}\.[0-9]{2}\.[0-9]{4}
-------------------------



cnp [5-6][0-9]{12}


data [0-9]{2}:[0-9]{2}   cifra de 2 ori: cifra de 2 ori

-------------------------


sau
0   0 : 0 0
[0-1]  [0-9] [0-5] [0-9]

^ inceput
$ final
-------------------------





--------------------------
vim test.txt
click dreapta
esc
:wq enter

 



-------------------------------------------------------------------------------------------------------------------------

EXPRESII REGEX:
expresii regex ca sa cautam patternuri

-------------------------------------------------------------------------------------------------------------------------


GREP:
grep - afiseaza  searches the input file and prints all the lines which contain the given pattern


-E ia tot fisierul la analizat ne lasa sa scriem regex  
extended regulary expression ca sa avem o gama mai mare de proprietati

grep caurta un anumit patter/regeex si ne arata liniile care se potrivesc cu cuvantul sau un regex mai complex
sed o folosim ca sa editam
s  de la subsring ca sa inlocuiasca cu altceva un regex


 

grep [OPTIONS] PATTERN [FILE...]

grep [OPTIONS] [-e PATTERN] [-f FILE...] [FILE...]

OPTIONS:

-c (--count) print a count of matching lines

-i (--ignore-case) ignore case distinctions

-v (--invert-match) invert the sense of matching

-q quiet

-E Extended Regular Expressions

-C NUM (-NUM --context=NUM) print NUM lines from all matching lines


exemple:
grep -E -i “\<dan\>|\<ana\>” /etc/pseudopasswd

grep -E -i “^[aeiou][^:]:” /etc/pseudopasswd

grep -E -i -o “^[aeiou][^:]:” /etc/pseudopasswd

grep -E -i “nologin$” /etc/pseudopasswd










s - de la substitue  [0-9]/aici nu punem nimic orice cf se inlocuieste cu nimic /g    g- global -> tot randul

daca nu punem g sterge doar prima cifra din fiecare rand


+ orice litera  mica sau mare o data sau de mai multe ori


grep cu adresa de email deifnim noi 
inventam una
4 litere 2 cf
si la host litere mari litere mici underscore


-------------------------------------------------------------------------------------------------------------------------

SED:  - editeaza  (Stream EDitor)

is a non-interactive text editor used to perform basic text transformations on an input stream

reads and process all lines of the input stream one by one, and prints the result on the screen

command syntax:


sed [-n] [-e] '[/pattern/]command' [input-file]

sed [-n] -f script-file [input-file]

-n suppress automatic printing of internal buffer (pattern space)

-e script add script to the commands to be executed

-f script-file add the contents of script-file to the commands to be executed

- the input stream may be: the standard input stream (keyboard), a file denoted by input-file or the result of another command(s) execution

- if not specified a pattern, a certain line, or multiple lines, command will be executed on all the lines of input stream

§ selecting lines (line addressing):

N just line N

$ just last line

M, N from line M to line N

M~step from line M, lines from step to step

/regexp/ just the lines containing the pattern given by regexp

0, /regexp/ just the first line containing the pattern given by regexp

M, +N from line M, N lines after

M, ~N from line M, all the lines which are multiple of N


commands:

- p (print)

sed '2,5p' angajati.txt

sed '/Ion/,/Victor/p' angajati.txt

- d (delete)

sed '/Tudor/d' angajati.txt


- s (substitute) s/regex/repl/[gi] : substitute first occurrence of regex in a line with repl; flags g for global replacement (all matching in the line), i for case insensitive regex

sed 's/Tudor/Tudorel/' angajati.txt

sed –n 's/Tudor/Tudorel/' angajati.txt

sed 's/19/18/g' angajati.txt

sed 's/1931/1932/gi' angajati.txt

sed -E 's/(Ion)el/\1ut/gi' angajati.txt

sed -E 's/[0-9][0-9]$/&\.5/' angajati.txt

sed '/Olga/,/Toma/s/$/**CONCEDIU**/' angajati.txt

sed -E “s/[0-9]/*/g” /etc/pseudopasswd

sed -E “s/[0-9]/*/” /etc/pseudopasswd

sed -E “s/[aeiou]/&&&/g” /etc/pseudopasswd

sed -E “s/[aeiou]/&&&/gi” /etc/pseudopasswd

sed -E “s/([aeiou])([aeiou])/\2\1/gi” /etc/pseudopasswd

sed -E “s/[^:]//gi” /etc/pseudopasswd

- y (transform) - ex. replace each lowercase vowel with the corresponding uppercase vowel (the initial list and replacement list must have the same length, performs 1 to 1 transliteration)

sed 'y/aeiou/AEIOU/' /etc/pseudopasswd

-------------------------------------------------------------------------------------------------------------------------

AWK - is not only a text processing utility, but also an interpreted programming language with a C-like syntax



command syntax:

awk [OPTIONS] '/pattern/' [input-file]

awk [OPTIONS] '{action}' [input-file]

awk [OPTIONS] '/pattern/{action}' [input-file]

-F fs to change the default input field separator with fs

-f script-file to obtain the commands from script-file


awk reads and process all lines of the input file one by one

§ each line represents an input record

§ default input record separator: CR (Carriage Return)

§ the current input record is stored in the internal variable $0

§ each input record is parsed and separated into chunks called fields

§ default input field separators: SPACE or TAB

§ built-in variables:

$0 the current input record

$1, $2, ... the fields of the current input record

NR the total number of input records seen so far

NF the number of fields in the current input record

RS the input record separator

ORS the output record separator

FS the input field separator

OFS the output field separator

OFMT the format for converting numbers to strings for printing with print

ARGC the number of command line arguments

ARGV the array of command line arguments

FILENAME the name of the current input file

FNR the current record number in the current file

ENVIRON the array of environment variables



examples:

- print all lines of the input file:

awk -F'[ :\t]' '{print $1, $2, $3}' angajati.txtawk '{print}' angajati.txt

awk '{print $0}' angajati.txt

- print all lines which contain the given pattern:

awk '/Tudor/' angajati.txt

awk '/Tudor/{print}' angajati.txt

awk '/Tudor/{print $0}' angajati.txt

- change the default input field separator:

awk -F: '{print $1}' /etc/passwd

awk -F: '{print NR, $1}' /etc/passwd





examples:

- using relational operators:

awk '$5 < 2000' angajati.txt

awk '$5 < 2000 {print}' angajati.txt

awk ' $5 == 1942 {print NR, $1}' angajati.txt

- using relational operators and regular expressions:

awk ' $1 ~ /Tudor/ {print}' angajati.txt

awk ' $1 !~ /Tudor/ {print}' angajati.txt



logical operators: && || !

§ arithmetic operators: + - * / % ^

§ assignment operators: = += -= *= /= %= ^=

§ conditional expressions:

condition ? expresion1 : expresion2

is equivalent with:

if (condition)

expresion1

else

expresion2


scripts:

- BEGIN: commands are executed once only, BEFORE the first input record is read

- END: commands are executed once only, AFTER all the input is read

- {} between BEGIN și END: commands are executed for each input record

- examples:

awk 'BEGIN{FS = ":"}' /etc/passwd

awk 'BEGIN{FS = ":"; OFS="\t"} {print $1, S2}' /etc/passwd

awk '/Ion/{cnt++}END{print "Ion apare de " cnt " ori."}' angajati.txt

awk 'END{print "Nr. angajati: " NR}' angajati.txt

awk 'BEGIN{total=0} {total++} END{print "Total: " total}' angajati.txt



instructions:

http://www.grymoire.com/Unix/AwkRef.html

§ built-in functions:

http://www.grymoire.com/Unix/AwkRef.html




LAB 3 PROBLEME:

Problems:

Sed

Write a command that encodes the text in a file by replacing each letter with the following letter in the alphabet and removes the digits. Grep

Write all the lines in the text file that contain email addresses (of the form

username@hostname.co.me ). Define your own rules for accepted characters in an email.

Awk

For each user in /etc/pseudopasswd that has an odd userid, print the username and user info (name), sorted alphabetically. Add the record number for each line at the beginning.




REFERENCES:

§ Regular expressions: https://www.regular-expressions.info/quickstart.html

§ awk manual: https://linux.die.net/man/1/awk

§ awk tutorial: http://www.grymoire.com/Unix/Awk.html

§ grep manual: https://linux.die.net/man/1/grep

§ sed manual: https://linux.die.net/man/1/sed

§ sed tutorial: http://www.grymoire.com/Unix/Sed.html#uh-41



-------------------------------------------------------------------------------------------------------------------------



vim angajati.txt
click dreapta si i se da paste
esc :wq enter ca sa ies


 
 



deschidem cu nano angajati . txt si dam paste    vim angajati.txt
celelalt /etc/pseudopasswd 





vim
nano nume fisier

+ din regex 





vim angajati.txt
click dreapta si i se da paste
esc :wq enter ca sa ies




----------------------------------------------------------------------------------------------------------------

nano x deshcide fisier editor sa scrie in el
ctrl x

 touch t/a t/b

creare fisier in dir t  cu cale relativa

man tree
cu q iesi din manual


afisare continut fisier cat script.sh


nano deschide fisierul de editor text

\n
\r\n


rulare              $ ./ script  dar trebuie sa le dam drept de rulare
sau direct nume     $ script.sh


chmod schibam dreptul de executie


cum copiem dintrun director in altul
cum mutam  dintrun director in altul
mv sursa destinatie




man mv help la move






========================================


[sdar2590@linux fulga]$ pwd
/home/users/stud/licenta/2/324/sdar2590/fulga
[sdar2590@linux fulga]$ man nano
[sdar2590@linux fulga]$ nano
[sdar2590@linux fulga]$ nano
[sdar2590@linux fulga]$ ls -l
total 16
drwxr-xr-x. 3 sdar2590 gr324 4096 Mar  7 14:22 abc
-rw-r--r--. 1 sdar2590 gr324   17 Mar  7 14:30 fulga2.txt
drwxr-xr-x. 2 sdar2590 gr324 4096 Mar  7 14:18 tt
drwxr-xr-x. 2 sdar2590 gr324 4096 Mar  7 14:21 zz
[sdar2590@linux fulga]$ nano
abc/        fulga2.txt  tt/         zz/
[sdar2590@linux fulga]$ nano
abc/        fulga2.txt  tt/         zz/
[sdar2590@linux fulga]$ nano fulga2.txt
[sdar2590@linux fulga]$ ls -l
total 20
drwxr-xr-x. 3 sdar2590 gr324 4096 Mar  7 14:22 abc
-rw-r--r--. 1 sdar2590 gr324   17 Mar  7 14:30 fulga2.txt
-rw-r--r--. 1 sdar2590 gr324   55 Mar  7 14:38 fulga3.txt
drwxr-xr-x. 2 sdar2590 gr324 4096 Mar  7 14:18 tt
drwxr-xr-x. 2 sdar2590 gr324 4096 Mar  7 14:21 zz
[sdar2590@linux fulga]$ ls -a
.  ..  abc  fulga2.txt  fulga3.txt  tt  zz
[sdar2590@linux fulga]$ nano script.sh
[sdar2590@linux fulga]$ cat script
cat: script: No such file or directory
[sdar2590@linux fulga]$ cat script.sh
mkdir abc
mkdir zz
mkdir tt
cd zz
touch x
cd ..
cd abc
touch x y t1 t2 t3
mkdir t
touch t/a t/b
cd ..

[sdar2590@linux fulga]$ ./script.sh
-bash: ./script.sh: Permission denied
[sdar2590@linux fulga]$ ls -l
total 24
drwxr-xr-x. 3 sdar2590 gr324 4096 Mar  7 14:22 abc
-rw-r--r--. 1 sdar2590 gr324   17 Mar  7 14:30 fulga2.txt
-rw-r--r--. 1 sdar2590 gr324   55 Mar  7 14:38 fulga3.txt
-rw-r--r--. 1 sdar2590 gr324  103 Mar  7 14:41 script.sh
drwxr-xr-x. 2 sdar2590 gr324 4096 Mar  7 14:18 tt
drwxr-xr-x. 2 sdar2590 gr324 4096 Mar  7 14:21 zz
[sdar2590@linux fulga]$ chmod 764 script.sh


7 =111
6 =110
4 = 100
1 grup proprietAR FISIER
2 grup din care face parte prop
3 oricine



[sdar2590@linux fulga]$ ls-l
-bash: ls-l: command not found
[sdar2590@linux fulga]$ ls -l
total 24
drwxr-xr-x. 3 sdar2590 gr324 4096 Mar  7 14:22 abc
-rw-r--r--. 1 sdar2590 gr324   17 Mar  7 14:30 fulga2.txt
-rw-r--r--. 1 sdar2590 gr324   55 Mar  7 14:38 fulga3.txt
-rwxrw-r--. 1 sdar2590 gr324  103 Mar  7 14:41 script.sh
drwxr-xr-x. 2 sdar2590 gr324 4096 Mar  7 14:18 tt
drwxr-xr-x. 2 sdar2590 gr324 4096 Mar  7 14:21 zz
[sdar2590@linux fulga]$ tree
.
├── abc
│   ├── t
│   │   ├── a
│   │   └── b
│   ├── t1
│   ├── t2
│   ├── t3
│   ├── x
│   └── y
├── fulga2.txt
├── fulga3.txt
├── script.sh
├── tt
└── zz
    └── x

4 directories, 11 files
[sdar2590@linux fulga]$ mkdir fulganou
[sdar2590@linux fulga]$ mv script.sh ./fulganou/
[sdar2590@linux fulga]$ ls
abc  fulga2.txt  fulga3.txt  fulganou  tt  zz
[sdar2590@linux fulga]$ cd fulganou
[sdar2590@linux fulganou]$ ;s
-bash: syntax error near unexpected token `;'
[sdar2590@linux fulganou]$ ls
script.sh
[sdar2590@linux fulganou]$ ls -l
total 4
-rwxrw-r--. 1 sdar2590 gr324 103 Mar  7 14:41 script.sh
[sdar2590@linux fulganou]$ ./script.sh
[sdar2590@linux fulganou]$ tree
.
├── abc
│   ├── t
│   │   ├── a
│   │   └── b
│   ├── t1
│   ├── t2
│   ├── t3
│   ├── x
│   └── y
├── script.sh
├── tt
└── zz
    └── x
 







nano script2.sh creare fisier
 

s=$(expr $s + $1)  $1 il introducem noi de la tastatuea
s = 0+23 / 21 

sau 
s=$(($s + $1))
echo $s





suma numerelor

for i in $*;
do
	s=$(($s+$i))
done
echo $s





-----------------------------

2> redirectam stder intr un fisier
fara 2 redirectam doar iesirea standar


LAB 6 SO


#!/bin/bash
n=$1

# Check if the parameter is a number
if [[ ! $n =~ ^[0-9]+$ ]]; then
    echo "$n nu e numar"
    exit 1
fi

# Check if the number is negative, positive, or zero
if [ "$n" -gt 0 ]; then
    echo "$n is positive"
elif [ "$n" -lt 0 ]; then
    echo "$n is negative"
else
    echo "$n is zero"
fi







#!/bin/bash
n=$1
if [[! $n =~ ^-?[0-9]+$]]; then
        echo $n nu e numar
        exit 1
fi







#!/bin/bash
dir=$1

if [ ! -d $dir ]
then
        echo "trebuie sa fie director"
        exit 1
fi






#!/bin/bash
 

if [ ! -f "$1" ]
then
        echo "trebuie sa fie fisier"
        exit 1
fi







#!/bin/bash
 
if [ ! -f "$1" ]; then
    echo "Primul parametru trebuie să fie un fișier."
    exit 1
fi

shift

# Iterate through remaining parameters and validate if they are numbers
for num in "$@"; do
    # Check if the parameter is a number
    if [[ ! $num =~ ^[0-9]+$ ]]; then
        echo "$num nu este un număr."
        exit 1
    fi
done

echo "Toate parametrii următori sunt numere."








#!/bin/bash

if [ ! -f "$1" ]
then
        echo "trebuie sa fie fisier"
        exit 1
fi

shift


for num in "$@"; do
        if [[ ! $num =~ ^[0-9]+$ ]]; then
        echo "$num nu este un numar."
        exit 1
    fi
done

echo "toti parametrii sunt numere"


-------------------------


#!/bin/bash

if [ ! -f "$1" ]
then
        echo "trebuie sa fie fisier"
        exit 1
fi

shift


for cuv in "$@"; do
        if [[ ! $cuv =~ ^[a-zA-Z]+$ ]]; then
        echo "$cuv nu e cuvant."
        exit 1
    fi
done

echo "toti parametrii sunt cuvinte"

 



#!/bin/bash

if [ ! -f "$1" ]
then
        echo "trebuie sa fie fisier" >&2
        exit 1
fi

mkdir -p dictionar

for digit in {0..9}; do
        grep -E "^$digit" "$1" | sort -u > "dictionar/$digit"
done

 


 

grep a fulga.txt -> afiseaza randurile care contin litera a

grep ^m fulga.txt -> afiseaza randurile care incep cu litera m
grep a$ fulga.txt -> afiseaza randurile care se temina cu litera m
grep ^a$ fulga.txt -> afis randurile care incep si se termina cu a
grep [0-9] ->  randurile care contin cifre
 
grep -E [0-9]{2} fulga.txt -> daca gaseste o cifra afiseaza randul ; -E = extended regex (ca sa recunoasca elemente precum {})

grep -E "^[0-9].[0-9]$" -> afis expr de forma cifra caracter cifra

grep -E "^[0-9].[0-9]$" -> ceva de forma: cifra ... (ceva, orice, inclusiv sirul vid) cifra

 -E = extended regex (ca sa recunoasca elemente precum {})
 . = orice caracter
 * = ori de cate ori 
 .* = orice caracter ori de cate ori(inclusiv sirul vid)
 + = minim un caracter 
 
 
 ca sa afisam date de genul: aaaa.ll.zz:
 grep -E "[0-9]{4}\.[0-9][0-9]\.[0-9][0-9]"
 
 pt validare luna:
 grep -E "[0-9]{4}\.(0[1-9]|1[0-2])\.[0-9][0-9]"
 
 pt validare zi:
 grep -E "[0-9]{4}\.(0[1-9]|1[0-2])\.[0-2][0-9]|3[0-1]"
 
 pt. validare serie de buletin (CJ123456) / noile buletine o sa aiba 7 cifre: 
 grep -E "[a-zA-Z]{2}[0-9]{6,7}" 
 
 
 
 
 sed -r "s/0000/year/" fulga.txt -> inlocuieste doar prima aparite din rand 0000 cu year
 sed -r "s/0000/year/g" fulga.txt -> inlocuieste toate aparitiile din rand 0000 cu year
 
  g de la final = global
 
 sed -r "s/[0-9]{4}/year/" fulga.txt ->
 
 sed -r "s/[0-9]/year/g" fulga.txt -> inlocuieste fiecare cifra cu year
 
 sed -r "y/0123/abcd/" fulga.txt -> inlocuieste 0 cu a, 1 cu b, 2 cu c si 3 cu d 
 
 
 sed -r "s/([a-z]*) ([a-z]*)/\2 \1/" fulga.txt ->  inlocuieste primul cuvant cu al doilea cuvant (inclusiv cu string-ul vid)
	ex:  padure cu    -> cu padure
		 ramburs      -> (spatiu)ramburs 
		 
		 
grep -E "^(a-z)* .* \1$" fulga.txt -> cauta liniile care incep si se termina cu acelasi cuvant (format doar din litere, fara cifre)


LAB 1,2,3,4,5,6 COMENZI LINUX


Ctrl-C Oprește execuția programului care rulează la momentul actual

Ctrl-Z Suspendă execuția programului care rulează la momentul actual

Ctrl-D Închide sesiunea de lucru (în anumite situații este echivalent cu EOF)



FILES AND DIRECTORIES PERMISSIONS

- pentru fiecare fişier sau director sunt specificate drepturi de acces (permissions)

- afişare drepturi de acces: ls -l

- rwx  rwx  rwx

   u    g    o


reprezentarea simbolică a rolurilor:

- u (owner) - proprietarul fişierului/directorului

- g (group) - grupul din care face parte proprietarul fişierului/directorului

- o (others) - utilizatorii care nu sunt în grupul din care face parte proprietarul



reprezentarea simbolică a drepturilor de acces pentru fişiere:

- r (read) - dreptul de a citi conţinutul fişierului

- w (write) - dreptul de a scrie în fişier

- x (execute) - dreptul de a lansa în execuţie fişierul


reprezentarea simbolică a drepturilor de acces pentru directoare:

- r (read) - dreptul de a citi conţinutul directorului (vizualizare fişiere/sub-directoare)

- w (write) - dreptul de a scrie în director (creare fişiere/sub-directoare)

- x (execute) - dreptul de a intra în director



reprezentarea numerică a drepturilor de acces:

r (read) = 4 w (write) = 2 x (execute) = 1




- modificarea drepturilor de acces:

chmod +x file_name

chmod 755 file_name

chmod g+r file_name

chmod u+rw, g+r-w, g+r file_name

chmod u=rwx, g=rw, o=r file_name
 


------------------------------------------
ALTELE
STANDARD STREAMS REDIRECTION. CONNECTING COMMANDS WITH PIPES

§ the UNIX shells use three standard streams:

- 0 = standard input (STDIN)

- 1 = standard output (STDOUT)

- 2 = standard error (STDERR)


symbols used to:
- redirect the standard input: <

- redirect the standard output/standard error:

> (if the file exists, the file content will be overwritten)

>> (if the file exists, append the output to the existing file content)


examples:

---- redirect standard input:

cat sort sort <users.txt


----- redirect standard output to a file:

ls -l >list.txt or ls -l 1>list.txt

ls -l >>list.txt or ls -l 1>>list.txt


----- redirect standard error to a file:

ls -l /bonus >error.log or ls -l /bonus 2>error.log

ls -l /bonus >>error.log or ls -l /bonus 2>>error.log


----- redirect standard output and standard error to the same file:

ls -l /bonus >output.log 1>&2

ls -l /bonus >>output.log 1>>&2


-- connecting commands with pipes:

who | sort

who | wc -l

sort users.txt | head -n 5

sort users.txt | tail -n 5



------------------------------------------



man grep / etc

mkdir nume_folder
cp dir_src dir_dest -> Copiază directorul dir_src în directorul dir_dest
mv dir_src dir_dest -> Mută directorul dir_src în directorul dir_dest
rmdir nume_dir ->  Șterge directorul al cărui nume e furnizat ca argument


touch nume_fisier
cp fis_src fis_dest -> Copiază fișierul fis_src în fișierul fis_dest
mv fis_src fis_dest -> Mută fișierul fis_src în fișierul fis_dest
rm nume_fisier -> Șterge fișierul al cărui nume e furnizat ca argument
cat nume_fisier -> Afișează conținutul fișierului furnizat ca argument



rmdir

command + option + value: ls -l /etc
			  cat -n hello.c

ps

file

df

cd dir = change directories -> Schimbă directorul curent cu cel specificat

cat


ls - list -> Afișează conținutul directorului curent
ls -l -d -a -p 
ls -all

rm -r -i -f
cp -r -i -f
mv -i -f


jobs

ln

du

bg

find

diff

less

fg

pwd = print working directory - Afișează directorul curent

passwd

more

chmod

kill


1. Listați conținutul următoarelor directoare: / /bin /usr /etc /usr/include

Acolo unde este cazul, paginați listarea (ls | less).


2. Căutați textul printf în fișierul /usr/include/stdio.h (folosind less)


3. Creați următoarea structură de directoare și fișiere în directorul vostru personal:

(dir. personal)
.
├── abc
│   ├── t(director)
│   │   ├── a(fișier)
│   │   └── b(fișier)
│   ├── t1(fișier)
│   ├── t2(fișier)
│   ├── t3(fișier)
│   ├── x(fișier)
│   └── y(fișier)
├── tt(director)
└── zz(director)
    └── x(fișier)



mkdir fulga
cd fulga

mkdir abc
mkdir zz
mkdir tt
 ls -> abc  tt  zz

cd zz
ls
nano x

cd zz + cd fulga nu merg

cd ..  - asta trebuie

ls
abc  tt  zz
 cd zz
 ls

touch x
ls
x

cd ..

cd abc
touch x
touch y
touch t1 t2 t3
 ls -> t1  t2  t3  x  y

 mkdir t
 touch t/a t/b
 ls -> t  t1  t2  t3  x  y

 ls t   -> a  b

 cd ..
 tree
.
├── abc
│   ├── t
│   │   ├── a
│   │   └── b
│   ├── t1
│   ├── t2
│   ├── t3
│   ├── x
│   └── y
├── tt
└── zz
    └── x


4. Copiați întreg conținutul (recursiv) directorului abc în directorul zz (abc va deveni subdirector în directorul zz).

5. Copiați conținutul lui abc în directorul zz fără a suprascrie fișierele cu acelasi nume (x, în cazul nostru).

6. Copiați fișierele t1 și t2 din directorul abc în directorul tt (folosind specificator generic).


10. Creați în directorul tt o legătură simbolică cu numele c către directorul abc.

Explorați funcționarea acestei legături simbolice vis-a-vis de comenzile cd și pwd



7. Creați un nou director cu dreptul de acces x, dar nu și r.

Creați un fișier în acest director. Ce observați ?

Dați apoi acestui director dreptul de acces r și eliminați x. Ce observați ?



8. Dați drepturile de acces potrivite astfel încât:

- oricine să poată vizualiza conținutul directoarelor abc și abc/t

- oricine să poată adăuga fișiere în directorul abc/t

- oricine să poată citi fișierele x, y, t1, t2, t3 din abc, dar să nu poată citi fișierele a și b din directorul abc/t.

Listați în format lung fișierele t, t1, t2, t3 din directorul abc (astfel încât să fie vizibile drepturile de acces ale lui t, și nu cele ale fișierelor pe care acesta le conține).



9. Comanda cp /dev/zero /dev/null este un fel de "ciclu infinit" (nu se termină).

Lansați comanda de mai sus, mutați-o în background, listați procesele active, terminați comanda (în ambele variante: comanda trebuie mutată în foreground și oprită cu ^C sau cu kill).



-----------------------------------

Lab 3

^ the start of line

$ the end of line

\< the empty string at the beginning of a word

\> the empty string at the end of a word

\b \b equivalent with \< \>




? either zero or one time

* zero or more times

+ one or more times

{n} exactly n times

{n,} n times or more

{,m} at most m times

{n,m} at least n times, but at most m times




.  - orice caracter
\. - caracterul .
\
/
^
$
|
?
*
+
()
{}
[]: [abc] o singura litera dintre (a, b or c)
[^abc] -NEGATA -> o singura litera in afara de a,b,c => (d, e, ..., z)
[a-z] doar litere mici -> o singura litera mica de la a la z
[A-Z]
[a-zA-Z] si litere mici si mari -> o singura litera mica sau mare de la a la Z
[0-9]  echivalent cu \d     -> o singura cifra de la 0 la 9
[^0-9] un singur caracter care NU e cifra
\s     a single whitespace char (including SPACE, TAB, CR, LF)
\w echivalent cu [a-zA-Z0-9_]   ->  a single alfanumeric char or _ (underscore)
\w in regular expressions matches any word character. It includes alphanumeric characters (letters and digits) as well as the underscore _.


Hello, world! This is an example text with some numbers like 123 and special characters.
\w+

\w: Matches any word character (alphanumeric characters and underscore).
+: Quantifier that matches one or more occurrences of the preceding character or group.
Hello
world
This
is
an
example
text
with
some
numbers
like
123
and
special
characters


daca nu punem + -> doar \w => caractere INDIVIDUALE
H
e
l
l
o
w
o
r
l
d ....


-----------------------


GREP - afiseaza


OPTIONS:

-c (--count) print a count of matching lines

-i (--ignore-case) ignore case distinctions

-v (--invert-match) invert the sense of matching

-q quiet

-E Extended Regular Expressions

-C NUM (-NUM --context=NUM) print NUM lines from all matching lines



grep -E -i "^[ab]" pseudopasswd   ---lini ce incep cu litera a sau b
grep -E -i "[^ab]" pseudopasswd   ---lini ce NU incep cu litera a sau b
grep -E -i "\<dan\>" pseudopasswd  --- Dan = dan = DAN pt ca am pus -i IGNORE CASE
grep -E -i "\<dan\>|\<horia\>" pseudopasswd

grep -E -i "^[aeiou]" pseudopasswd
grep -E -i "^[aeiou][^:]" pseudopasswd
grep -E -i "^[aeiou][^:]:" pseudopasswd



grep -E -i “\<dan\>|\<ana\>” /etc/pseudopasswd
grep -E -i “nologin$” /etc/pseudopasswd


-----------------------

grep -E -i 'Alin|Aricescu' pseudopasswd | sort
grep -E 'Zoso|Himalaya' pseudopasswd | sort



-----------------------

SED - editeaza

command syntax:

sed [-n] [-e] '[/pattern/]command' [input-file]

sed [-n] -f script-file [input-file]

-n suppress automatic printing of internal buffer (pattern space)

-e script add script to the commands to be executed

-f script-file add the contents of script-file to the commands to be executed

- the input stream may be: the standard input stream (keyboard), a file denoted by input-file or the result of another command(s) execution

- if not specified a pattern, a certain line, or multiple lines, command will be executed on all the lines of input stream


selecting lines (line addressing):

N just line N

$ just last line

M, N from line M to line N

M~step from line M, lines from step to step

/regexp/ just the lines containing the pattern given by regexp

0, /regexp/ just the first line containing the pattern given by regexp

M, +N from line M, N lines after

M, ~N from line M, all the lines which are multiple of N




commands:

- p (print)

 sed -n '2,5p' angajati.txt  - printeaza liniile de la 2 la 5, -n surpress spacs

sed '/Ion/,/Victor/p' angajati.txt

- d (delete)

sed '/Tudor/d' angajati.txt  sterge persoana cu numele Tudor


- s (substitute) s/regex/repl/[gi] : substitute first occurrence of regex in a line with repl; flags g for global replacement (all matching in the line), i for case insensitive regex


sed 's/Tudor/Tudorel/' angajati.txt   -printeaza toate liniile

sed –n 's/Tudor/Tudorel/' angajati.txt  -printeaza doar liniile unde s a facut subsitutia adica avea numele Tudor  

sed 's/19/18/g' angajati.txt   schimba 9 cu 18

sed 's/1931/1932/gi' angajati.txt   g global i sensitive lowercase/uppercase

sed -E 's/(Ion)el/\1ut/gi' angajati.txt  Ion el -> Ion ut

sed -E 's/[0-9][0-9]$/&\.5/' angajati.txt


Ionel Popescu 10/3/1961:Colinei,2,Cluj-Napoca:0740-123456 3500
Vasile Georgescu 5/10/1942:Piata Republicii,35,Cluj-Napoca:0722-654321 2850
Alexandru Ionescu 3/7/1971:Aleea Bibliotecii,10,Cluj-Napoca:0721-124536 3875
Tudor Alexandrescu 2/5/1963:Aleea Baisoara,53,Cluj-Napoca:0742-235641 2355
Victor Baciu 25/9/1968:Eroilor,105,Floresti:0723-162453 4560
denisa@DESKTOP-K5RTQGH:~/exercitii$ sed -E 's/[0-9][0-9]$/&\.5/' angajati2.txt

Ionel Popescu 10/3/1961:Colinei,2,Cluj-Napoca:0740-123456 3500.5
Vasile Georgescu 5/10/1942:Piata Republicii,35,Cluj-Napoca:0722-654321 2850.5
Alexandru Ionescu 3/7/1971:Aleea Bibliotecii,10,Cluj-Napoca:0721-124536 3875.5
Tudor Alexandrescu 2/5/1963:Aleea Baisoara,53,Cluj-Napoca:0742-235641 2355.5
Victor Baciu 25/9/1968:Eroilor,105,Floresti:0723-162453 4560.5
denisa@DESKTOP-K5RTQGH:~/exercitii$ sed -E 's/[0-9]$/&\.5/' angajati2.txt

Ionel Popescu 10/3/1961:Colinei,2,Cluj-Napoca:0740-123456 3500.5
Vasile Georgescu 5/10/1942:Piata Republicii,35,Cluj-Napoca:0722-654321 2850.5
Alexandru Ionescu 3/7/1971:Aleea Bibliotecii,10,Cluj-Napoca:0721-124536 3875.5
Tudor Alexandrescu 2/5/1963:Aleea Baisoara,53,Cluj-Napoca:0742-235641 2355.5
Victor Baciu 25/9/1968:Eroilor,105,Floresti:0723-162453 4560.5




sed '/Ionel/,/Vasile/s/$/**CONCEDIU**/' angajati2.txt

- final rand pune concediu

Ionel Popescu 10/3/1961:Colinei,2,Cluj-Napoca:0740-123456 3500**CONCEDIU**
Vasile Georgescu 5/10/1942:Piata Republicii,35,Cluj-Napoca:0722-654321 2850**CONCEDIU**
Alexandru Ionescu 3/7/1971:Aleea Bibliotecii,10,Cluj-Napoca:0721-124536 3875
Tudor Alexandrescu 2/5/1963:Aleea Baisoara,53,Cluj-Napoca:0742-235641 2355
Victor Baciu 25/9/1968:Eroilor,105,Floresti:0723-162453 4560



sed '/Ionel/,/Victor/s/$/**CONCEDIU**/' angajati2.txt

de la IONEL - LA VICTOR RANGE PUNE LA TOTI

Ionel Popescu 10/3/1961:Colinei,2,Cluj-Napoca:0740-123456 3500**CONCEDIU**
Vasile Georgescu 5/10/1942:Piata Republicii,35,Cluj-Napoca:0722-654321 2850**CONCEDIU**
Alexandru Ionescu 3/7/1971:Aleea Bibliotecii,10,Cluj-Napoca:0721-124536 3875**CONCEDIU**
Tudor Alexandrescu 2/5/1963:Aleea Baisoara,53,Cluj-Napoca:0742-235641 2355**CONCEDIU**
Victor Baciu 25/9/1968:Eroilor,105,Floresti:0723-162453 4560**CONCEDIU**




sed -E “s/[0-9]/*/g” /etc/pseudopasswd   --- NUMERELE LE SUBST CU *

aaie0001:x:1:600:Aricescu Alin:/home/scs/gr911/aaie0001:/bin/bash
abie0002:x:2:600:Aricescu Bogdan:/home/scs/gr911/abie0002:/bin/bash
acie0003:x:3:600:Aricescu Cornel:/home/scs/gr911/acie0003:/bin/bash
adie0004:x:4:600:Aricescu Dan:/home/scs/gr911/adie0004:/bin/bash
aeie0005:x:5:600:Aricescu Emil:/home/scs/gr911/aeie0005:/bin/bash

 sed -E "s/[0-9]/*/g" pseudopasswd.txt
aaie****:x:*:***:Aricescu Alin:/home/scs/gr***/aaie****:/bin/bash
abie****:x:*:***:Aricescu Bogdan:/home/scs/gr***/abie****:/bin/bash
acie****:x:*:***:Aricescu Cornel:/home/scs/gr***/acie****:/bin/bash
adie****:x:*:***:Aricescu Dan:/home/scs/gr***/adie****:/bin/bash




sed -E “s/[0-9]/*/” pseudopasswd

subsituie doar prima cifra gasita pe fiecare linie

sed -E "s/[0-9]/*/" pseudopasswd.txt
aaie*001:x:1:600:Aricescu Alin:/home/scs/gr911/aaie0001:/bin/bash
abie*002:x:2:600:Aricescu Bogdan:/home/scs/gr911/abie0002:/bin/bash
acie*003:x:3:600:Aricescu Cornel:/home/scs/gr911/acie0003:/bin/bash
adie*004:x:4:600:Aricescu Dan:/home/scs/gr911/adie0004:/bin/bash






sed -E "s/[aeiou]/&&&/g" pseudopasswd.txt   DUPLICATE VOCALE a e i o u de 3 ori fiecare

aaaaaaiiieee0001:x:1:600:Ariiiceeescuuu Aliiin:/hooomeee/scs/gr911/aaaaaaiiieee0001:/biiin/baaash
aaabiiieee0002:x:2:600:Ariiiceeescuuu Booogdaaan:/hooomeee/scs/gr911/aaabiiieee0002:/biiin/baaash
aaaciiieee0003:x:3:600:Ariiiceeescuuu Cooorneeel:/hooomeee/scs/gr911/aaaciiieee0003:/biiin/baaash
aaadiiieee0004:x:4:600:Ariiiceeescuuu Daaan:/hooomeee/scs/gr911/aaadiiieee0004:/biiin/baaash
aaaeeeiiieee0005:x:5:600:Ariiiceeescuuu Emiiil:/hooomeee/scs/gr911/aaaeeeiiieee0005:/biiin/baaash
aaafiiieee0006:x:6:600:Ariiiceeescuuu Floooriiin:/hooomeee/scs/gr911/aaafiiieee0006:/biiin/baaash
aaagiiieee0007:x:7:600:Ariiiceeescuuu Gaaabriiieeel:/hooomeee/scs/gr911/aaagiiieee0007:/biiin/baaash
aaahiiieee0008:x:8:600:Ariiiceeescuuu Hoooriiiaaa:/hooomeee/scs/gr911/aaahiiieee0008:/biiin/baaash
aaaliiieee0009:x:9:600:Ariiiceeescuuu Laaauuureeentiiiuuu:/hooomeee/scs/gr911/aaaliiieee0009:/biiin/baaash
aaamiiieee0010:x:10:600:Ariiiceeescuuu Maaariiiuuus:/hooomeee/scs/gr911/aaamiiieee0010:/biiin/baaash
aaaniiieee0011:x:11:600:Ariiiceeescuuu Niiicooolaaaeee:/hooomeee/scs/gr911/aaaniiieee0011:/biiin/baaash



sed -E "s/[aeiou]/&&&/gi" pseudopasswd.txt    -i  ia in considerare si vocalele mari

aaaaaaiiieee0001:x:1:600:AAAriiiceeescuuu AAAliiin:/hooomeee/scs/gr911/aaaaaaiiieee0001:/biiin/baaash
aaabiiieee0002:x:2:600:AAAriiiceeescuuu Booogdaaan:/hooomeee/scs/gr911/aaabiiieee0002:/biiin/baaash






sed -E “s/([aeiou])([aeiou])/\2\1/gi” pseudopasswd.txt

aaei0001:x:1:600:Aricescu Alin:/home/scs/gr911/aaei0001:/bin/bash
abei0002:x:2:600:Aricescu Bogdan:/home/scs/gr911/abei0002:/bin/bash
acei0003:x:3:600:Aricescu Cornel:/home/scs/gr911/acei0003:/bin/bash
adei0004:x:4:600:Aricescu Dan:/home/scs/gr911/adei0004:/bin/bash
eaei0005:x:5:600:Aricescu Emil:/home/scs/gr911/eaei0005:/bin/bash
afei0006:x:6:600:Aricescu Florin:/home/scs/gr911/afei0006:/bin/bash
agei0007:x:7:600:Aricescu Gabreil:/home/scs/gr911/agei0007:/bin/bash
ahei0008:x:8:600:Aricescu Horai:/home/scs/gr911/ahei0008:/bin/bash
alei0009:x:9:600:Aricescu Luarentui:/home/scs/gr911/alei0009:/bin/bash
amei0010:x:10:600:Aricescu Maruis:/home/scs/gr911/amei0010:/bin/bash
anei0011:x:11:600:Aricescu Nicolea:/home/scs/gr911/anei0011:/bin/bash


cat pseudopasswd.txt
aaie0001:x:1:600:Aricescu Alin:/home/scs/gr911/aaie0001:/bin/bash
abie0002:x:2:600:Aricescu Bogdan:/home/scs/gr911/abie0002:/bin/bash
acie0003:x:3:600:Aricescu Cornel:/home/scs/gr911/acie0003:/bin/bash
adie0004:x:4:600:Aricescu Dan:/home/scs/gr911/adie0004:/bin/bash
aeie0005:x:5:600:Aricescu Emil:/home/scs/gr911/aeie0005:/bin/bash
afie0006:x:6:600:Aricescu Florin:/home/scs/gr911/afie0006:/bin/bash
agie0007:x:7:600:Aricescu Gabriel:/home/scs/gr911/agie0007:/bin/bash
ahie0008:x:8:600:Aricescu Horia:/home/scs/gr911/ahie0008:/bin/bash
alie0009:x:9:600:Aricescu Laurentiu:/home/scs/gr911/alie0009:/bin/bash
amie0010:x:10:600:Aricescu Marius:/home/scs/gr911/amie0010:/bin/bash
anie0011:x:11:600:Aricescu Nicolae:/home/scs/gr911/anie0011:/bin/bash

sed -E "s/[^:]//" pseudopasswd.txt   taie prima litera din fiecare rand
aie0001:x:1:600:Aricescu Alin:/home/scs/gr911/aaie0001:/bin/bash
bie0002:x:2:600:Aricescu Bogdan:/home/scs/gr911/abie0002:/bin/bash
cie0003:x:3:600:Aricescu Cornel:/home/scs/gr911/acie0003:/bin/bash
die0004:x:4:600:Aricescu Dan:/home/scs/gr911/adie0004:/bin/bash
eie0005:x:5:600:Aricescu Emil:/home/scs/gr911/aeie0005:/bin/bash
fie0006:x:6:600:Aricescu Florin:/home/scs/gr911/afie0006:/bin/bash
gie0007:x:7:600:Aricescu Gabriel:/home/scs/gr911/agie0007:/bin/bash
hie0008:x:8:600:Aricescu Horia:/home/scs/gr911/ahie0008:/bin/bash
lie0009:x:9:600:Aricescu Laurentiu:/home/scs/gr911/alie0009:/bin/bash
mie0010:x:10:600:Aricescu Marius:/home/scs/gr911/amie0010:/bin/bash
nie0011:x:11:600:Aricescu Nicolae:/home/scs/gr911/anie0011:/bin/bash


sed -E "s/[^:]//gi" pseudopasswd.txt  --- inlocuieste bucatile split uite dupa : cu nimic
::::::
::::::
::::::
::::::
::::::
::::::
::::::
::::::
::::::
::::::
::::::




- y (transform) - ex. replace each lowercase vowel with the corresponding uppercase vowel (the initial list and replacement list must have the same length, performs 1 to 1 transliteration)

sed 'y/aeiou/AEIOU/' pseudopasswd.txt     <=> sed -E 's/a/A/g;s/e/E/g;s/i/I/g;s/o/O/g;s/u/U/g' pseudopasswd.txt

 <=> sed 's/[aeiou]/\U&/g' pseudopasswd.txt



AAIE0001:x:1:600:ArIcEscU AlIn:/hOmE/scs/gr911/AAIE0001:/bIn/bAsh
AbIE0002:x:2:600:ArIcEscU BOgdAn:/hOmE/scs/gr911/AbIE0002:/bIn/bAsh
AcIE0003:x:3:600:ArIcEscU COrnEl:/hOmE/scs/gr911/AcIE0003:/bIn/bAsh


sed 's/a/A/' pseudopasswd.txt
Aaie0001:x:1:600:Aricescu Alin:/home/scs/gr911/aaie0001:/bin/bash
Abie0002:x:2:600:Aricescu Bogdan:/home/scs/gr911/abie0002:/bin/bash
Acie0003:x:3:600:Aricescu Cornel:/home/scs/gr911/acie0003:/bin/bash



-----------------------------------


AWK - reads and process all lines of the input file one by o

command syntax:

awk [OPTIONS] '/pattern/' [input-file]

awk [OPTIONS] '{action}' [input-file]

awk [OPTIONS] '/pattern/{action}' [input-file]


each line represents an input record

 default input record separator: CR (Carriage Return)

 the current input record is stored in the internal variable $0

 each input record is parsed and separated into chunks called fields

 default input field separators: SPACE or TAB



$0 the current input record

$1, $2, ... the fields of the current input record

NR the total number of input records seen so far

NF the number of fields in the current input record

RS the input record separator

ORS the output record separator

FS the input field separator

OFS the output field separator

OFMT the format for converting numbers to strings for printing with print

ARGC the number of command line arguments

ARGV the array of command line arguments

FILENAME the name of the current input file

FNR the current record number in the current file

ENVIRON the array of environment variables




examples:

awk '{print}' angajati.txt   - prints all lines of the input file

awk '{print $0}' angajati.txt - intreaga linie

awk '/Tudor/' angajati.txt  - CAUTA LINII CE CONTIN CUVANTUL TUDOR SI LE PRINTEAZA
Tudor Alexandrescu 2/5/1963:Aleea Baisoara,53,Cluj-Napoca:0742-235641 2355
Olga Tudorache 24/1/1932:Florilor,41,Floresti:0744-458712 1942
Silviu Achim 19/10/1936:Tudor Vladimirescu,18,Cluj-Napoca:0726-369147 1932

awk '/Tudor/{print}' angajati.txt   - same thing
 
awk '/Tudor/{print $0}' angajati.txt - same thing


- change the default input field separator:

awk -F: '{print $1}' pseudopasswd.txt
 -F: specifies the field separator as :. This means that AWK will treat each line as composed of fields separated by colons.
'{print $1}' tells AWK to print the first field of each line.

aaie0001
abie0002
acie0003
adie0004
aeie0005
afie0006
agie0007
ahie0008
alie0009
amie0010
anie0011


awk -F: '{print NR, $1}' pseudopasswd.txt    NR - afiseaza numarul / indexul liniei



awk -F'[ :\t]' '{print $1, $2, $3}' angajati.txt   - NE IA DOAR PRIMELE 3 FIELD URI
  
angajati2.txt

Ionel Popescu 10/3/1961:Colinei,2,Cluj-Napoca:0740-123456 3500
Vasile Georgescu 5/10/1942:Piata Republicii,35,Cluj-Napoca:0722-654321 2850
Alexandru Ionescu 3/7/1971:Aleea Bibliotecii,10,Cluj-Napoca:0721-124536 3875
Tudor Alexandrescu 2/5/1963:Aleea Baisoara,53,Cluj-Napoca:0742-235641 2355
Victor Baciu 25/9/1968:Eroilor,105,Floresti:0723-162453 4560


awk -F'[ :\t]' '{print $1, $2, $3}' angajati2.txt

Ionel Popescu 10/3/1961
Vasile Georgescu 5/10/1942
Alexandru Ionescu 3/7/1971
Tudor Alexandrescu 2/5/1963
Victor Baciu 25/9/1968


--------------------------------

awk '{print $0}' angajati2.txt

Ionel Popescu 10/3/1961:Colinei,2,Cluj-Napoca:0740-123456 3500
Vasile Georgescu 5/10/1942:Piata Republicii,35,Cluj-Napoca:0722-654321 2850
Alexandru Ionescu 3/7/1971:Aleea Bibliotecii,10,Cluj-Napoca:0721-124536 3875
Tudor Alexandrescu 2/5/1963:Aleea Baisoara,53,Cluj-Napoca:0742-235641 2355
Victor Baciu 25/9/1968:Eroilor,105,Floresti:0723-162453 4560

 awk '{print $1}' angajati2.txt

Ionel
Vasile
Alexandru
Tudor
Victor

 awk '{print $2}' angajati2.txt

Popescu
Georgescu
Ionescu
Alexandrescu
Baciu

 awk '{print $3}' angajati2.txt

10/3/1961:Colinei,2,Cluj-Napoca:0740-123456
5/10/1942:Piata
3/7/1971:Aleea
2/5/1963:Aleea
25/9/1968:Eroilor,105,Floresti:0723-162453

 awk '{print $4}' angajati2.txt

3500
Republicii,35,Cluj-Napoca:0722-654321
Bibliotecii,10,Cluj-Napoca:0721-124536
Baisoara,53,Cluj-Napoca:0742-235641
4560



Operator Name Example

< less than x < y

<= less than or equal to x <= y

== equal x == y

!= not equal x != y

> greather than x > y

>= greather than or equal to x >= y

~ matches the regular expression x ~ /regexp/

!~ does not match the regular expression x !~ /regexp/

logical operators: && || !
arithmetic operators: + - * / % ^
assignment operators: =   +=   -=   *=   /=    %=   ^=


examples:

- using relational operators:

awk '$5 < 2000' angajati2.txt

awk '$5 < 2000 {print}' angajati2.txt
/
awk ' $5 == 1942 {print NR, $1}' angajati2.txt   -> 2 Vasile  




- using relational operators and regular expressions:

awk ' $1 ~ /Tudor/ {print}' angajati.txt -- cauta chiar linia cu tudor si ii da print

awk ' $1 !~ /Tudor/ {print}' angajati.txt -- cauta liniile FARA tudor si le da print

 


conditional expressions:

condition ? expresion1 : expresion2


is equivalent with:

if (condition)

	expresion1

else

	expresion2


-----------------
scripts:

- BEGIN: commands are executed once only, BEFORE the first input record is read

- END: commands are executed once only, AFTER all the input is read

- {} between BEGIN și END: commands are executed for each input record



- examples:

awk 'BEGIN{FS = ":"}' pseudopasswd.txt

awk 'BEGIN{FS = ":"; OFS="\t"} {print $1, S2}' pseudopasswd.txt

aaie0001
abie0002
acie0003
adie0004
aeie0005
afie0006
agie0007
ahie0008
alie0009
amie0010
anie0011


awk '/Ion/{cnt++}END{print "Ion apare de " cnt " ori."}' angajati2.txt

Ion apare de 2 ori.   --- Ionel si Ionescu


Ionel Popescu 10/3/1961:Colinei,2,Cluj-Napoca:0740-123456 3500
Vasile Georgescu 5/10/1942:Piata Republicii,35,Cluj-Napoca:0722-654321 2850
Alexandru Ionescu 3/7/1971:Aleea Bibliotecii,10,Cluj-Napoca:0721-124536 3875
Tudor Alexandrescu 2/5/1963:Aleea Baisoara,53,Cluj-Napoca:0742-235641 2355
Victor Baciu 25/9/1968:Eroilor,105,Floresti:0723-162453 4560


awk 'END{print "Nr. angajati: " NR}' angajati2.txt

Nr. angajati: 5

Ionel Popescu 10/3/1961:Colinei,2,Cluj-Napoca:0740-123456 3500
Vasile Georgescu 5/10/1942:Piata Republicii,35,Cluj-Napoca:0722-654321 2850
Alexandru Ionescu 3/7/1971:Aleea Bibliotecii,10,Cluj-Napoca:0721-124536 3875
Tudor Alexandrescu 2/5/1963:Aleea Baisoara,53,Cluj-Napoca:0742-235641 2355
Victor Baciu 25/9/1968:Eroilor,105,Floresti:0723-162453 4560




awk 'BEGIN{total=0} {total++} END{print "Total: " total}' angajati.txt  
Total: 5





-----------------

Problems:


Sed
- remove all the digits from file
sed -E 's/[0-9]//g' angajati2.txt
 

- replacing each letter with the following letter in the alphabet. 

sed -E 'y/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/bcdefghijklmnopqrstuvwxyzaBCDEFGHIJKLMNOPQRSTUVWXYZA/' angajati2.txt


NU MERGE PE SED -I igonre case  ---- trebuie pus manual
DOAR PE GREP

- replacing each letter with the following letter in the alphabet and removes the digits. 

sed -E 'y/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/bcdefghijklmnopqrstuvwxyzaBCDEFGHIJKLMNOPQRSTUVWXYZA/' angajati2.txt | sed -E 's/[0-9]//g'




Grep

Write all the lines in the text file that contain email addresses (of the form

username@hostname.co.me ). Define your own rules for accepted characters in an email.



Awk

For each user in pseudopasswd.txt that has an odd userid, print the username and user info (name), sorted alphabetically. Add the record number for each line at the beginning.





https://www.regular-expressions.info/quickstart.html
awk manual: https://linux.die.net/man/1/awk

§ awk tutorial: http://www.grymoire.com/Unix/Awk.html

§ grep manual: https://linux.die.net/man/1/grep

§ sed manual: https://linux.die.net/man/1/sed

§ sed tutorial: http://www.grymoire.com/Unix/Sed.html#uh-41


-----------------------------------


-----------------------------------

Lab 4 AWK + SCRIPTS

nano script.sh


#!/bin/bash 
pwd 
ls


chmod +x script.sh

./script.sh



variables:

- variable names can contain letters, digits and „ _” (underscore), first character must be a letter, reserved words can not be used as var names

- all is case sensitive (distinction between uppercase and lowercase letters

- examples:

n=45

name=Ana

msg="Enter a number:"




reserved words (keywords):

if then else elif fi

for while until do done

case in esac





internal commands (built-in commands):

- print the list of internal commands: help

- print information about a command: help command

- examples: echo read printf test





special variables:

$0 Name of the script file

$1,..., $9 Command line arguments given for execution

$# Number of command line arguments given

$* Array of command line arguments

$@ List of individual command line arguments

$? Exit code (exit status) of the last executed command

$$ PID-ul of the current process

$! PID-ul of the last command launched in background


-----------------------------------

Lab 5  SCRIPTS 


putty
v m - VMWare Virtual Box
WSL - ubuntu
stick


commands
cd ~ - schimbam directorul pe care vrem  sa lucram
cd / - fisierul root
pwd - print working directory
ls - directoarele directoarele
ls root - fisierele de peste tot
ls -l - listeaza folderele cu toate informatiile
- - fisier
d - director
touch name - creeaza un fisier name
man touch - folosim manual pt instructiune
mkdir name- creeaza un director name
echo ceva - printeaza ceva pe ecran
echo ceva > doc322 - printeaza in fisier ceva
ls -l doc322
cat doc322 - continutul fisierului
nano - editare - ctrl x - exit
	       - ctrl o - save la fisier
citire standard
iesire standard -> redirectare standard
>> - append la fisier
> redirectare modifica 

x- execute 
r- read
w- write
grupe - 3 - primul - owner
	    al doilea - grupul din care face parte
	    al treilea - others

utilitar chmod 
chmod - dat / luat drepturi - 0 / 444 

chmod 0 
chmod 777 doc322

touch abc/t/a abc/t/b


0 -> ---
1 -> --x
2 -> _w_
3 -> -wx
4 -> r-x
5 -> rw-
7 -> rwx

mkdir zz; touch zz/x




if test `TEST 5 -GT 4`
-le
-ne
-gt

var=$1
echo $var
if [ 5 -gt 4 ]; then
        echo "ceva"
fi

if [ $1  -gt 4 ]; then
        echo "$1 mai mare de 4"
else
        echo "$1 nu mai mare decat 4"
fi


# !/bin/bash
for i in $*
do
        echo $i
done


fisiere=`ls`
for i in $fisiere
do
        echo $i
done

readlink -f - path ul absolut al lui work dir
cat /dev/null > "$summary_result_path"
IFS_ORIG=$IFS -> ///separator spatiu
IFS=$'\n' -> se modifica separatorul in BACKSLASH


        var=` wc -l file | cut -d ' ' -f 1

        var=` wc -l file | cut -d ' ' -f 1

 wc -l enunt.txt | cut -d ' ' -f 1



[grep] - utilitar [regex]-ceva [fisier]-fis
^... ce incep cu ceva
...$ care se term cu ceva
[ap] contine a sau p
[ap][ai] al/ai/pi/pl

grep -E "^(.*) .* \1$" fis
	  incepe cu orice are spatiu contine orice are spatiu si primul coincide cu ultimul cuvant

sed -re "s/a/z	





AWK
functioneaza pe baza de scenarii
conditie {actiuni}
parcurge linie cu linie si verifica validatea scenariului
procesand tot la nivel de linie


awk '{print $0}' fulga.txt - fiecare linie

awk '{print $1}' fulga.txt - primul cuvant din fiecare linie

awk -F',' '{print $1}' fulga.txt - schimbam separatorul in virgula

FNR - renumeroteaza liniile
NR - liniile procesate

 awk  '/^a/ {print $1}' fulga.txt - primul cuvant incepe cu a
 awk -f file.awk fulga.txt - asa rulam


#!/bin/bash
echo '{for(i=1;i<NF;i++) if($i==$(i+1)) print NR, $i}' > filee.awk
awk -f filee.awk $1


-----------------------------------



Lab 6



-----------------------------------

NF = NUMBER OF FIELDS



awk -F, '{print $1}' flg
nano roua.awk
awk -f "roua.awk" flg


BEGIN {print "inceput"}
{print $1}
END {print "sfarsit"}


BEGIN {print "inceput"}
BEGIN {FS=","}
{print $1}
END {print "sfarsit"}


BEGIN {print "inceput"}
/^a/ {print $1}
END {print "sfarsit"}



BEGIN {FS=","}
{print $1, $4-$3}
END {print "sfarsit"}  nume + cati ani a dormit


sau 

BEGIN {FS=","}
{print $1, $NF-$(NF-1)}
END {print "sfarsit"}


an = anul fiec domn
BEGIN {FS=","}
{an=$4-$3; print an}
END {print "sfarsit"}


 
BEGIN {FS=","}
{an=$4-$3;
    if (max<an) {
        max=an;
        dom=$1;
    }
}
END {print dom,max}



OFS AFISARE
FS CIITIRE

BEGIN {FS=","; OFS=";"}
{an=$4-$3;
    if (max<an) {
        max=an;
        dom=$1;
    }
}
END {print dom,max}


cronologic dommnitori din sec 20s



BEGIN {FS=","; OFS=";"}
{an=$4-$3;
    if (max<an) {
        max=an;
        dom=$1;
    }
}
END {print dom,max}





ceva nu merge
BEGIN {FS=","; OFS=";"}
{aninceput=$3;
 ansfarsit=$4;
    if (aninceput>=1900 && ansfarsit<=2000) {


        domnitori[$1] = $3;
        print $1, $3"-"$4;

    }
}
END {
        asort(domnitori);
        for (domn in domnitori)
        {
                print dom, domnitori[dom];
        }
}






------------------------------------

BEGIN {FS=","; OFS=";"}
$3>1899 {print $1,$3}




awk -f "roua.awk" flg.txt | sort -t ";" -k 2
ferdinand I;1916
alexandru ioan cuza;1920
joseph stalin;1921
alexandru cel bun;1930
adolf hitler;1933
nicolae ceausescu;1965
fulga;2013


------------------------------------



BEGIN {
 print "------------------"
 i=0
}

$NF == "bdate1"{

   print NR "I wanna go home!!!"

}


NF < 3{

   print ">>>" NR "  " $0 "<<<"

}


{
  print NR "===>" $1 " " $NF
  i+=NF
}

{

  j=0

  for (j = 1; j <= NF; j++)
  {
     print "...." $j
     v[$j]++
  }

}


END {
 print "=================="
 print i

 for (f in v)
 {
    print f " apears " v[f] " times"

 }

 560  cat 3 | awk '{}'
  564  cat 3 | awk '{$0}'
  565  cat 3 | awk '{print $0}'
  566  cat 3 | awk '{print $1}'
  567  cat 3 | awk '{print $2}'
  568  cat 3 | awk '{print $3}'
  569  cat 3 | awk '{print $3444}'
  571  cat 3 | awk '{print $0 $3}'
  572  cat 3 | awk '{print $0 "----" $3}'
  574  man awk
  575  cat 3 | awk '{print FNR}'
  578  cat 3 | awk '{print FNR}'
  579  cat 3 | awk '{print NR}'
  580  cat 3 | awk '{print Nf}'
  581  cat 3 | awk '{print NF}'
  584  cat 3 | awk '{print NF NR}'
  585  cat 3 | awk '{print NF --- NR}'
  586  cat 3 | awk '{print NF "---" NR}'
  587  cat 3 | awk '{print $0 "====" NF "---" NR}'
  588  cat 3 3| awk '{print $0 "====" NF "---" NR}'
  589  cat 3 3 3| awk '{print $0 "====" NF "---" NR}'
  590  cat 3| awk '{print $0 "====" NF "---" NR}'
  593  cat 3| awk '{print $0 "====" NF "---" NR}'
  604  cat 4| awk -F , '{print $0 "====" NF "---" NR}'
  605  cat 4| awk  '{print $0 "====" NF "---" NR}'
  607  cat 4| awk -F , '{print $0 "====" NF "---" NR}'
  608  man awk
  609  cat 4| awk -F , '{print $0 "====" $1 "---" NR}'
  610  cat 4| awk -F , '{print $0 "====" $1 "---" $NF}'
  611  cat 4| awk -F , '{print $0 " ==== " $1 " --- " $NF}'
  613  cat 4| awk -F , '{print $0 " ==== " $1 " --- " $NF}'
  614  cat 4| awk -F , '{print $0 " ==== " $1 " --- " $(NF - 1)}'
  615  cat 4| awk -F , '{print $0 " ==== " $1 " --- " $(NF - 2)}'
  616  cat 4| awk -F , '{print $0 " ==== " $1 " --- " $(NF - 3)}'
  618  joe 1.awk
  620  cat 3 | awk -f 1.awk -F ,
  621  cat 1.awk
  622  cat 4 | awk -f 1.awk -F ,
  623  joe 1.awk
  625  cat 4 | awk -f 1.awk -F ,
  626  joe 1.awk
  628  cat 4 | awk -f 1.awk -F ,
  632  joe 1.awk
  634  cat 4 | awk -f 1.awk -F ,
  636  joe 1.awk
  638  cat 4 | awk -f 1.awk -F ,
  639  joe 1.awk
  641  cat 4 | awk -f 1.awk -F ,
  642  joe 1.awk
  644  cat 4 | awk -f 1.awk -F ,
  645  joe 1.awk
  647  cat 4 | awk -f 1.awk -F ,
  648  joe 1.awk
  650  cat 4 | awk -f 1.awk -F ,
  651  joe 1.awk
  653  cat 4 | awk -f 1.awk -F ,
  654  joe 1.awk
  656  cat 4 | awk -f 1.awk -F ,
  659  man awk
  972  man awk
  976  cat 1.awk
  982  cat 8 | awk '{print "I wann go home!!"}'
  983  cat /etc/passwd | awk '{print "I wann go home!!"}'
  984  cat /etc/passwd | awk '{print "I wanna go home!!"}'
  990  cat 2.awk
  991  cat /etc/passwd | awk -f 2.awk
  992  cat /etc/passwd | awk -f 2.awk '{print "somethig else"}'
  993  cat /etc/passwd | awk  '{print "somethig else"}' -f 2.awk
  994  cat /etc/passwd | awk -f 2.awk -f 2.awk
  995  cat /etc/passwd | awk -f 1.awk -f 2.awk
 1002  cat 1.awk









  363  cat 1 | grep "[0-9]"
  364  cat 1 | grep "[a-z]"
  365  cat 1 | grep "[A-Z]"
  367  cat 1 | grep "[13579]"
  368  cat 1 | grep "[^13579]"
  369  cat 1 | grep "[^0-9]"
  374  cat 1 | grep "[0-9][a-z]"
  375  cat 1 | grep "[0-9][a-z]*"
  376  cat 1 | grep "[0-9][a-z]"
  377  cat 1 | grep "[0-9][a-z]*"
  378  cat 1 | grep "[0-9][a-z]"
  389  cat 2 | grep -E "^[0-9]"
  391  cat 2 | grep -E "^[0-9]"
  392  cat 2 | grep -E "^[0-9]+"
  393  cat 2 | grep -E "^[0-9]+[-+*]"
  394  cat 2 | grep -E "^[0-9]+[-+*/]"
  396  cat 2 | grep -E "^[0-9]+[-+*/]"
  397  cat 2 | grep -E "^([0-9]+[-+*/])+"
  398  cat 2 | grep -E "^([0-9]+[-+*/])+[0-9]+"
  399  cat 2 | grep -E "^([0-9]+[-+*/]{1})+[0-9]+"
  400  cat 2 | grep -E "^([0-9]+[-+*/])+[0-9]+="
  403  cat 2 | grep -E "^([0-9]+[-+*/])+[0-9]+="
  404  cat 2 | grep -E "^([0-9]+[-+*/]+)+[0-9]+="
  405  cat 2 | grep -E "^([0-9]+[-+*/])+[0-9]+="
  408  cat 2 | grep -E "^([0-9]+[-+*/])+[0-9]+="
  409  cat 2 | grep -E "^([0-9]+[-+*/])+[0-9]+=[0-9]"
  410  cat 2 | grep -E "^([0-9]+[-+*/])+[0-9]+=[0-9]+"
  412  cat 2 | grep -E "^[0-9]+([-+*/]+[0-9]+)*=[0-9]+"
  413  cat 2 | grep -E "^[0-9]+([-+*/]+[0-9]+)*=[0-9]+[+-*/][0-9]+"
  415  cat 2 | grep -E "^[0-9]+([-+*/]+[0-9]+)*=[0-9]+[+-*/][0-9]+"
  416  cat 2 | grep -E "^[0-9]+([-+*/]+[0-9]+)*=[0-9]+[-+*/][0-9]+"
  417  cat 2 | grep -E "^[0-9]+([-+*/]+[0-9]+)*=[0-9]+([-+*/][0-9]+)*"
  419  cat 2 | grep -E "^[0-9]+([-+*/]+[0-9]+)*=[0-9]+([-+*/][0-9]+)*"
  420  cat /etc/passwd | grep -i bianca
  421  cat /etc/passwd | grep -i 911
  427  cat /etc/passwd | grep -i bianca
  429  cat /etc/passwd | grep -i bianca
  437  cat /etc/passwd | grep 911
  438  #cat /etc/passwd | grep 911
  440  grep "911" /etc/passwd
  447  mkdir grep
  448  mv regex  grep/
  449  cd grep/
  455  cat /etc/passwd | grep ex4
  456  cat /etc/passwd | grep ex3
  457  cat /etc/passwd | grep ex4
  655  xm show-room --room bradut-lab3-911-1 | grep -i diana
  703  man grep
  800  ls grep/
  808  cat 1 | grep "firstname1"
  809  cat 1 | grep "firstname"
  810  cat 3 | grep "firstname"
  812  cat 3 | grep "firstname"
  813  cat 3 | grep "firstname1"
  814  cat 3 | grep "firstname1 bdate2'"
  815  cat 3 | grep "firstname1 bdate2"
  816  cat 3 | grep "firstname1.*bdate2"
  818  cat 3 | grep "firstname1.*bdate2"
  968  cat /etc/passwd | grep "911"
  971  man grep
  972  cat /etc/passwd | grep "andrei"
  973  cat /etc/passwd | grep -i "andrei"
  977  man grep
  983  cat 7 | grep "^a"
  984  cat 7 | grep "^a.*a$"
  988  cat 7 | grep "^a.*a$"
  991  cat 7 | grep -w "^a.*a$"
  992  cat 7 | grep -w "a.*a"
  993  cat 7 | grep -w "a"
  994  cat 7 | grep -w "^a.*a$"
  995  cat 7 | grep "^a.*a$"
  996  cat 7 | grep -w "^a.*a$"
  999  grep -V
 1002  man grep
 1004  grep -irn "write"
 1005  /bin/grep -irn "write"
 1006  man grep
 1013  cat 7 | grep "^a"
 1014  cat 7 | grep "^a" -A 3
 1015  cat 7 | grep "^a" -A 3 -B 1
 1016  cat 7 | grep "^a" -o -A 3 -B 1
 1019  cat /etc/passwd | grep -i "andrei"
 1020  cat /etc/passwd | grep -io "andrei"
 1022  man grep
 1023  cat /etc/passwd | grep -io "andrei"
 1024  cat /etc/passwd | grep -ion "andrei"
 1025  cat /etc/passwd | grep -ioc "andrei"
 1026  cat /etc/passwd | grep -ic "andrei"
 1027  cat /etc/passwd | grep -io "andrei"
 1028  cat /etc/passwd | grep -io "andrei" | wc -l
 1029  cat /etc/passwd | grep -io "andrei"
 1031  man grep
 1047  cat 7 | grep "[0-9]{2,}[13579]"
 1048  cat 7 | grep -W "[0-9]{2,}[13579]"
 1049  cat 7 | grep -E "[0-9]{2,}[13579]"
 1050  cat 7 | grep -E "[0-9]{2,}[13579][^0-9]"
 1051  cat 7 | grep -E "[0-9]{2,}"
 1053  cat 7 | grep -E "[0-9]{2,}[13579][^0-9]"
 1054  cat 7 | grep "[0-9]{2,}[13579][^0-9]"
 1055  cat 7 | grep "[0-9]\{2,\}[13579][^0-9]"
 1056  cat 7 | grep -E "[1-9][0-9]+[13579][^0-9]"
 1057  cat 7 | grep -Ew "[1-9][0-9]+[13579][^0-9]"
 1058  cat 7 | grep -E "[1-9][0-9]+[13579][^0-9]"
 1060  cat 7 | grep -Ew "[1-9][0-9]+[13579][^0-9]"
 1061  cat 7 | grep -E "[1-9][0-9]+[13579][^0-9]"
 1062  cat 7 | grep -E "[1-9][0-9]+[13579]"
 1063  cat 7 | grep -Ew "[1-9][0-9]+[13579]"
 1065  cat 7 | grep -E "[1-9][0-9]+[13579]([^0-9]|$)"
 1066  cat 7 | grep -E "[1-9][0-9]+[13579][^0-9]"
 1067  cat 7 | grep -E "[1-9][0-9]+[13579][^0-9]" | grep "^[2468]"
 1072  cat 7 | grep "^1.*2$"
 1073  cat 7 | grep "^1.*2$|^3.*5$"
 1074  cat 7 | grep "^1.*2$\|^3.*5$"
 1075  cat 7 | grep -E "^1.*2$|^3.*5$"
 1078  cat 7 | grep -E "^1.*2$|^3.*5$"
 1079  cat 7 | grep -E "^(1|3).*(2|5)$"
 1082  cat 7 | grep -E "^(1|3).*(2|5)$"
 1083  cat 7 | grep -E "^1.*2$|^3.*5$"
 1084  grep -E "^1.*2$|^3.*5$" 7
 1085   grep -E "^(1|3).*(2|5)$"
 1086  grep -E "^1.*2$|^3.*5$" < 7
 1088  grep -E "^1.*2$|^3.*5$"
 1089* grep -E "^1.*2$|^3.*5$"
 1090  grep -E "^1.*2$|^3.*5$"
 1091  cat 7 | grep "^(1|3).*(2|5)$"
 1092  cat 7 | grep "^\(1\|3\).*\(2\|5\)$"








 408  sed -e "s/room/helicopter/g" 1
  409  sed -e "s/room/helicopter/g"
  410  cat 1 | sed -e "s/room/helicopter/g"
  412  cat 1 | sed -e "s/room/helicopter/g"
  413  sed -e "s/room/helicopter/" 1
  416  sed -e "s/room/helicopter/" 1
  417  sed -e "s/room/helicopter/g" 1
  418  sed -e "s/room/helicopter/g" 1 -i
  420  sed -e "s/helicopter/room/g" 1 -i
  424  sed -e "y/01234566789/asdfghjkl/" 1
  425  sed -e "y/01234566789/asdfghjkl;/" 1
  426  sed -e "y/01234566789/asdfghjklz/" 1
  427  sed -e "y/0123456789/asdfghjkl/" 1
  428  sed -e "y/0123456789/asdfghjklz/" 1
  429  man sed
  433  sed -e "s/room/33333/" 1
  434  sed -e "s/[rR]oom/33333/" 1
  435  sed -e "s/[rR]oom/33333/g" 1
  437  sed -e "s/[rR]oom/33333/g" 1
  438  sed -e "s/[rR]oom//g" 1
  439  sed -e "s/[rR]oom//g" -e "y/12345/qwert/" 1
  440  #sed -e "s/[rR]oom/55555/g" -e "y/12345/qwert/" 1
  444  sed -e "s/[rR]oom/55555/g"  1
  468  cat 2 | sed ""
  469  cat 2 | sed "s/^[0-9]+//g"
  470  cat 2 | sed -E "s/^[0-9]+//g"
  471  cat 2 | sed "s/^[0-9]+//g"
  472  cat 2 | sed -E "s/^[0-9]+//g"
  474  cat 2 | sed -E "s/^[0-9]+//g"
  475  cat 2 | sed -E "s/(^[0-9]+)//g"
  476  cat 2 | sed -E "s/(^[0-9]+).*[^0-9]([0-9]+)$//g"
  477  cat 2 | sed -E "s/(^[0-9]+)(.*[^0-9])([0-9]+)$//g"
  480  cat 2 | sed -E "s/(^[0-9]+)(.*[^0-9])([0-9]+)$//g"
  481  cat 2 | sed -E "s/(^[0-9]+)(.*[^0-9])([0-9]+)$/\1/g"
  482  cat 2 | sed -E "s/^[0-9]+.*[^0-9][0-9]+$/\1/g"
  483  cat 2 | sed -E "s/^[0-9]+.*[^0-9][0-9]+$/dd/g"
  484  cat 2 | sed -E "s/^[0-9]+.*[^0-9][0-9]+$/\1/g"
  486  cat 2 | sed -E "s/(^[0-9]+)(.*[^0-9])([0-9]+)$/\1/g"
  487  cat 2 | sed -E "s/(^[0-9]+)(.*[^0-9])([0-9]+)$/\1\2/g"
  488  cat 2 | sed -E "s/(^[0-9]+)(.*[^0-9])([0-9]+)$/\1\2\3/g"
  489  cat 2 | sed -E "s/(^[0-9]+)(.*[^0-9])([0-9]+)$/\3\2\1/g"
  490  cat 2 | sed -E "s/(^[0-9]+).*[^0-9]([0-9]+)$/\3\2\1/g"
  493  cat 2 | sed -E "s/(^[0-9]+).*[^0-9]([0-9]+)$/\2\1/g"
  494  cat 2 | sed -E "s/(^[0-9]+).*[^0-9]([0-9]+)$/\2===\1/g"
  495  cat 2 | sed -E "s/(^[0-9]+).*[^0-9]([0-9]+)$/\2\2\1\1/g"
  496  cat 2 | sed -E "s/(^[0-9]+).*[^0-9]([0-9]+)$/\2 \2 \1 \1/g"
  497  cat 2 | sed -E "s/(^[0-9]+).*[^0-9]([0-9]+)$/\2 \1 \2 \1 \1/g"
  499  cat 2 | sed -E "s/(^[0-9]+).*[^0-9]([0-9]+)$/\2 \1 \2 \1 \1/g"
  522  cat 2 | sed -E "s/(^[0-9]+).*[^0-9]([0-9]+)$/\2 \1 \2 \1 \1/g"
  523  cat 2 | sed -E "s/^[0-9]+.*[^0-9][0-9]+$//g"
  524  cat 2 | sed -E "s/^[0-9]+.*[^0-9][0-9]+$/&/g"
  525  cat 2 | sed -E "s/^[0-9]+.*[^0-9][0-9]+$/==&---/g"
  526  cat 2 | sed -E "s/^[0-9]+.*[^0-9][0-9]+$/==&&---/g"
  528  cat 2 | sed -E "s/^[0-9]+.*[^0-9][0-9]+$/==&&---/g"
  529  cat 2 | sed -E "s/^[0-9]+.*[^0-9][0-9]+$/==&&--/g"
  535  cat 5 | sed -e "s/name-okaceholder/2222/g" -e "s/addr-placehilder/666767/g" -e "s/bdate-placeholder/5464564/g"
  536  cat 5 | sed -e "s/name-placeholder/2222/g" -e "s/addr-placehilder/666767/g" -e "s/bdate-placeholder/5464564/g"
  537  cat 5 | sed -e "s/name-placeholder/2222/g" -e "s/addr-placeholder/666767/g" -e "s/bdate-placeholder/5464564/g"
  539  cat 5 | sed -e "s/name-placeholder/2222/g" -e "s/addr-placeholder/666767/g" -e "s/bdate-placeholder/5464564/g"
  594  cat 3 | sed "s/ /,/g" >4
  796  sed
  895  sed
  903  man sed
  910  man sed
  911  sed -e "" 7
  912  man sed
  916  cat 1 | sed -e "s/room/home/"
  917  cat 1 | sed -e "s/room/home/g"
  918  cat 1 | sed -e "s/room/home/gi"
  919  cat 1 | sed -e "s/room/home/g"
  921  cat 1 | sed -e "s/room/home/g"
  922  cat 1 | sed -e "s/[rR]oom/home/g"
  923  cat 1 | sed -e "s/Room/home/g" -e
  925  cat 1 | sed -e "s/Room/Home/g" -e "s/room/home/g"
  931  cat 2 | sed -E -e "s/^([0-9]+)(.*)([0-9]+)$//g"
  932  cat 2 | sed -E -e "s/^([0-9]+)(.*)([0-9]+)$/\3\2\1/g"
  933  cat 2 | sed -E -e "s/(^[0-9]+)(.*)([0-9]+$)/\3\2\1/g"
  935  history | grep sed'
  936  history | grep sed
  937  cat 2 | sed -E -e "s/(^[0-9]+)(.*)[^0-9]([0-9]+$)/\3\2\1/g"
  938  cat 2 | sed -E -e "s/(^[0-9]+)(.*[^0-9])([0-9]+$)/\3\2\1/g"
  941  cat 2 | sed -E -e "s/(^[0-9]+)(.*[^0-9])([0-9]+$)/\3\2\1/g"
  942  cat 2 | sed -E -e "s/(^[0-9]+)(.*[^0-9])([0-9]+$)/\3 \2 \2 \1/g"
  943  cat 2 | sed -E -e "s/(^[0-9]+)(.*[^0-9])([0-9]+$)/\3 \2 ==== \2 \1/g"
  944  cat 2 | sed -E -e "s/(^[0-9]+)(.*[^0-9])([0-9]+$)/\3\3---- \2 ==== \2 sadcsdc \1/g"
  946  cat 2 | sed -E -e "s/(^[0-9]+)(.*[^0-9])([0-9]+$)/\3 \2 ==== \5 \1/g"
  956  cat 8 | sed -e "s/(([0-9])([a-z]))/\1 \2 /g"
  957  cat 8 | sed -e "s/(([0-9])([a-z]))/\1 \2 \3/g"
  958  cat 8 | sed -e "s/(([0-9])([a-z]))/\1 \2/g"
  959  cat 8 | sed -e "s/(([0-9])([a-z]))/\1\2/g"
  960  cat 8 | sed -e "s/([0-9])([a-z])/\1\2/g"
  961  cat 8 | sed -E -e "s/(([0-9])([a-z]))/\1 \2 \3/g"
  963  cat 8 | sed -E -e "s/(([0-9])([a-z]))/\1 \2 \3/g"
  964  cat 8 | sed -e "s/\(\([0-9]\)\([a-z]\)\)/\1 \2 \3/g"
  965  cat 8 | sed -e "s/\(\([0-9]\)\([a-z]\)\)/1 = \1 2 = \2 3 = \3/g"
  966  cat 8 | sed -E -e "s/(([0-9])([a-z]))/1 = \1 2 = \2 3 = \3/g"
  967  cat 8 | sed -E -e "s/(([0-9]))([a-z])/1 = \1 2 = \2 3 = \3/g"
  968  cat 8 | sed -E -e "s/((([0-9])))([a-z])/1 = \1 2 = \2 3 = \3/g"


 
 
















