PIPE


// asemantor cu bota PB 1 vocale numere
 
//- creeaza 2 procese copil care comunica prin pipe

//- proces A citeste de la tastatura o singura data un numar intreg si il trimite prin pipe 
procesului b
//
- apoi citeste de la tastatura repetat numere intregi si le va trimite prin pipe procesului B, pana se introduce -1

//Procesul B va detremina si va afisa doar acele numere care sunt divizori ai lui n


./pr
100

20
e divizor

14
nu e divizor

-1  -> stop



// CU FIFO CU 2 FORKURI!!!!!!!!!!!!!

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>


int main(){


//if (mkfifo("pififo", 0666) == -1) {
  //      if (errno != EEXIST) {
    //        perror("Error creating FIFO");
      //      exit(1);
        //}
    //}


int pid=fork();

 if (pid==-1){
        perror("Eroare fork");

        exit(1);
}

if(pid==0)
{
   //copilul A

  int fd=open("p1fifo",O_WRONLY);
  if (fd == -1) {
            perror("Eroare deschidere FIFO");
            exit(1);
        }

 int n;

  printf("Introduceti n: \n");
  scanf("%d",&n);
  write(fd,&n,sizeof(int));

 int m;

 while(1) {

  printf("Introduceti sirul de numere pana la -1: \n");
  scanf("%d",&m);
  write(fd,&m,sizeof(int));

 if(m==-1) {break;}

}
 close(fd);
 exit(0);
}

int p2=fork();

 if (p2==-1){
        perror("Eroare fork");

        exit(1);
}

if (p2==0){ //proces B
int fd=open("p1fifo",O_RDONLY);

if (fd == -1) {
            perror("Eroare deschidere FIFO");
            exit(1);
        }

int n;
read(fd,&n,sizeof(int));
int m;
while(1){
        read(fd,&m,sizeof(int));

        if(m==-1) { break; }
        else
         {  if(n%m==0) {
        printf("%d Este divizor \n", m);  }

     else   printf("%d NU este divizor: \n", m);

          }

}
 close(fd);
 exit(0);
}


wait(0);
wait(0);
unlink("p1fifo");
return(0);
}



-------------------------------

FIFO 2 FORKURI DIVIZOR CITIRE DIN FISIER 

echo "5 12 15 55 67 51 10" > fis.txt

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s filename\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    FILE *file = fopen(argv[1], "r");
    if (!file) {
        perror("Error opening file");
        exit(EXIT_FAILURE);
    }

    int pid = fork();
    if (pid == -1) {
        perror("Error forking");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Child process A
        int fd = open("p3fifo", O_WRONLY);
        if (fd == -1) {
            perror("Error opening FIFO");
            exit(EXIT_FAILURE);
        }

        int n;
        fscanf(file, "%d", &n);
        write(fd, &n, sizeof(int));

        int m;
        while (fscanf(file, "%d", &m) != EOF) {
            write(fd, &m, sizeof(int));
        }

        close(fd);
        exit(EXIT_SUCCESS);
    }

    int p2 = fork();
    if (p2 == -1) {
        perror("Error forking");
        exit(EXIT_FAILURE);
    }

    if (p2 == 0) {
        // Child process B
        int fd = open("p3fifo", O_RDONLY);
        if (fd == -1) {
            perror("Error opening FIFO");
            exit(EXIT_FAILURE);
        }

        int n;
        read(fd, &n, sizeof(int));

        int m;
        while (read(fd, &m, sizeof(int)) > 0) {
            if (m == -1) {
                break;
            } else {
                if (n % m == 0) {
                    printf("%d Este divizor\n", m);
                } else {
                    printf("%d NU este divizor\n", m);
                }
            }
        }

        close(fd);
        exit(EXIT_SUCCESS);
    }

    wait(NULL);
    wait(NULL);

    return 0;
}
-------------------------daca citim linie cu linie

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>

#define FIFO_NAME "p3fifo"

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s filename\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    FILE *file = fopen(argv[1], "r");
    if (!file) {
        perror("Error opening file");
        exit(EXIT_FAILURE);
    }

    int pid = fork();
    if (pid == -1) {
        perror("Error forking");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Child process A
        int fd = open(FIFO_NAME, O_WRONLY);
        if (fd == -1) {
            perror("Error opening FIFO");
            exit(EXIT_FAILURE);
        }

        int n;
        fscanf(file, "%d", &n);
        write(fd, &n, sizeof(int));

        int m;
        char line[100]; // Modificare: Definim o variabilă pentru a citi fiecare linie
        while (fgets(line, sizeof(line), file) != NULL) { // Modificare: Citim linie cu linie
            sscanf(line, "%d", &m); // Modificare: Extragem numărul din linie
            write(fd, &m, sizeof(int));
        }

        close(fd);
        exit(EXIT_SUCCESS);
    }

    int p2 = fork();
    if (p2 == -1) {
        perror("Error forking");
        exit(EXIT_FAILURE);
    }

    if (p2 == 0) {
        // Child process B
        int fd = open(FIFO_NAME, O_RDONLY);
        if (fd == -1) {
            perror("Error opening FIFO");
            exit(EXIT_FAILURE);
        }

        int n;
        read(fd, &n, sizeof(int));

        int m;
        while (read(fd, &m, sizeof(int)) > 0) {
            if (m == -1) {
                break;
            } else {
                if (n % m == 0) {
                    printf("%d Este divizor\n", m);
                } else {
                    printf("%d NU este divizor\n", m);
                }
            }
        }

        close(fd);
        exit(EXIT_SUCCESS);
    }

    wait(NULL);
    wait(NULL);

    return 0;
}



---------------------

FIFO 2 FORKURI CMMDC

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

int gcd(int a, int b) {
    while (b != 0) {
        int t = b;
        b = a % b;
        a = t;
    }
    return a;
}

int main(int argc, char *argv[]){

if (argc != 2) {
        fprintf(stderr, "Usage: %s <N>\n", argv[0]);
        exit(1);
    }


 int N = atoi(argv[1]);
    const char *fifo_name = "p7fifo";

    if (mkfifo(fifo_name, 0666) == -1) {
        if (errno != EEXIST) {
            perror("Error creating FIFO");
            exit(1);
        }
    }


int pid=fork();

 if (pid==-1){
        perror("Eroare fork proces A");

        exit(1);
}

if(pid==0)
{
   //copilul A

  int fd=open("p7fifo",O_WRONLY);
  if (fd == -1) {
            perror("Eroare deschidere FIFO");
            exit(1);
        }

int m;
 while(1) {

  printf("Introduceti sirul de numere pana la -1: \n");
  scanf("%d",&m);
  write(fd,&m,sizeof(int));

 if(m==-1) {break;}

}
 close(fd);
 exit(0);
}

int p2=fork();

 if (p2==-1){
        perror("Eroare fork");

        exit(1);
}

if (p2==0){ //proces B
int fd=open("p7fifo",O_RDONLY);

if (fd == -1) {
            perror("Eroare deschidere FIFO");
            exit(1);
        }

int m;
while(1){
        read(fd,&m,sizeof(int));

        if(m==-1) { break; }
        if (gcd(N, m) == 1) {
                printf("Process B: %d has GCD 1 with %d\n", m, N);
            } else {
                printf("Process B: %d does not have GCD 1 with %d\n", m, N);
            }

}
 close(fd);
 exit(0);
}


wait(0);
wait(0);
unlink(fifo_name);
return(0);
}







---------------


CU PIPE CU 2 FORKURI!!!

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>


int main(){

int p12[2];

//pipe(p12);

    if (pipe(p12) == -1) {
        perror("Error creating pipe");
        exit(1);
    }

int pid=fork();

 if (pid==-1){
        perror("Eroare fork");

        exit(1);
}

if(pid==0)
{
   //copilul A

  close(p12[0]); //nu ne trebuie read la proc A

  int n;

  printf("Introduceti n: \n");
  scanf("%d",&n);
  write(p12[1],&n,sizeof(int));

 int m;

 while(1) {

  printf("Introduceti sirul de numere pana la -1: \n");
  scanf("%d",&m);
  write(p12[1],&m,sizeof(int));

 if(m==-1) {break;}

}
 close(p12[1]);
 exit(0);
}

int p2=fork();

 if (p2==-1){
        perror("Eroare fork");

        exit(1);
}

if (p2==0){ //proces B

close(p12[1]);// nu ii trimitem inapoi cu write, doar cu printf

int n;
read(p12[0],&n,sizeof(int));
int m;

while(1){
        read(p12[0],&m,sizeof(int));

        if(m==-1) { break; }
        else
         {  if(m!=0 && n%m==0) {
        printf("%d Este divizor \n", m);  }

     else   printf("%d NU este divizor: \n", m);

          }

}
 close(p12[0]);
 exit(0);
}

close(p12[0]);
close(p12[1]);

wait(0);
wait(0);
return(0);
}




---------------------------------------

// PRIN PIPE CU UN FORK

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>


int main(){

int p12[2];

//pipe(p12);

    if (pipe(p12) == -1) {
        perror("Error creating pipe");
        exit(1);
    }

int pid=fork();

 if (pid==-1){
        perror("Eroare fork");

        exit(1);
}

if(pid==0)
{
   //copilul A

close(p12[1]);// nu ii trimitem inapoi cu write, doar cu printf

int n;
read(p12[0],&n,sizeof(int));
int m;

while(1){
        read(p12[0],&m,sizeof(int));

        if(m==-1) { break; }
        else
         {  if(m!=0 && n%m==0) {
        printf("%d Este divizor \n", m);  }

     else   printf("%d NU este divizor: \n", m);

          }

}
 close(p12[0]);
 exit(0);
}


//
else{ //in parinte citim nr N si lista de numere

close(p12[0]); //nu ne trebuie read la proc A

  int n;

  printf("Introduceti n: \n");
  scanf("%d",&n);
  write(p12[1],&n,sizeof(int));

 int m;

 while(1) {

  printf("Introduceti sirul de numere pana la -1: \n");
  scanf("%d",&m);
  write(p12[1],&m,sizeof(int));

 if(m==-1) {break;}

}
 close(p12[1]);
 wait(0); // dam wait aici dupa copil
}

return(0);
}



--------------------

//prin PIPE CU UN FORK, COPILUL CITESTE, PARINTELE DA PRIN DACA E NR PRIM


#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdbool.h>

bool is_prime(int num) {
    if (num <= 1) return false;
    for (int i = 2; i <= num / 2; i++) {
        if (num % i == 0) return false;
    }
    return true;
}


int main(){

int p12[2];

//pipe(p12);

    if (pipe(p12) == -1) {
        perror("Error creating pipe");
        exit(1);
    }

int pid=fork();

 if (pid==-1){
        perror("Eroare fork");

        exit(1);
}

if(pid==0)
{
   //copilul A

close(p12[0]);// aici copilul CITESTE


        int num;
        while (1) {
            printf("Child: Enter a number (-1 to exit): \n");
            scanf("%d", &num);
            write(p12[1], &num, sizeof(int));
            if (num == -1) {
                break;
 }

}
 close(p12[0]);
 exit(0);
}


//
else{ //in parinte verifricam primalitatea

 close(p12[1]); // Close the write end of the pipe

        int num;
        while (1) {
            read(p12[0], &num, sizeof(int));
            if (num == -1) {
                break;
            }

            if (is_prime(num)) {
                printf("Parent: %d is a prime number.\n", num);
            } else {
                printf("Parent: %d is not a prime number.\n", num);
            }
        }


 close(p12[0]);
 wait(0); // dam wait aici dupa copil
}

return(0);
}




------------------------------------------------


////////////// prin fifo CU UN FORK

 
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>


int main(){


//if (mkfifo("pififo", 0666) == -1) {
    //        perror("Error creating FIFO");
      //      exit(1);
    //}


int pid=fork();

 if (pid==-1){
        perror("Eroare fork");

        exit(1);
}

if(pid==0)
{
   //copilul A

int fd=open("p1fifo",O_RDONLY);

if (fd == -1) {
            perror("Eroare deschidere FIFO");
            exit(1);
        }

int n;
read(fd,&n,sizeof(int));
int m;
while(1){
        read(fd,&m,sizeof(int));

        if(m==-1) { break; }
        else
         {  if(n%m==0) {
        printf("%d Este divizor \n", m);  }

     else   printf("%d NU este divizor: \n", m);

          }

}
 close(fd);
 unlink("p1fifo");
 exit(0);
}


else{ //in parinte

  int fd=open("p1fifo",O_WRONLY);
  if (fd == -1) {
            perror("Eroare deschidere FIFO");
            exit(1);
        }

 int n;

  printf("Introduceti n: \n");
  scanf("%d",&n);
  write(fd,&n,sizeof(int));

 int m;

 while(1) {

  printf("Introduceti sirul de numere pana la -1: \n");
  scanf("%d",&m);
  write(fd,&m,sizeof(int));

 if(m==-1) {break;}

}

 close(fd);
 wait(0);
 unlink("p1fifo");
}


return(0);
}



----------------------------------

FIFO 2 COPII FORK CU CITIRE STRING

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#define BUFFER_SIZE 256

int nrvoc(char *str){
  int nrvoc=0;
    for(int i=0;i<strlen(str); i++)
 {
    if(strchr("AEIOUaeiou",str[i])!= NULL)
         nrvoc++;
 }
 return nrvoc;

}

int main(){


//if (mkfifo("pififo", 0666) == -1) {
    //        perror("Error creating FIFO");
      //      exit(1);
    //}


int pid=fork();

 if (pid==-1){
        perror("Eroare fork");

        exit(1);
}

if(pid==0)
{
   //copilul A

  int fd=open("p2fifo",O_WRONLY);
  if (fd == -1) {
            perror("Eroare deschidere FIFO");
            exit(1);
        }

  char buffer[BUFFER_SIZE];

 while(1) {

  printf("Introduceti string si exit pt quit: \n");

  fgets(buffer, BUFFER_SIZE, stdin);
  buffer[strcspn(buffer, "\n")] = '\0';
  // Remove newline character

 if (strcmp(buffer, "exit") == 0) {
                break;
            }


  write(fd,buffer,strlen(buffer)+1);


}
 close(fd);
 exit(0);
}

int p2=fork();

 if (p2==-1){
        perror("Eroare fork");

        exit(1);
}

if (p2==0){ //proces B

int fd=open("p2fifo",O_RDONLY);

if (fd == -1) {
            perror("Eroare deschidere FIFO");
            exit(1);
        }

 char buffer[BUFFER_SIZE];
 while(1){

 int bytesRead = read(fd, buffer, BUFFER_SIZE);
            if (bytesRead == -1) {
                perror("Error reading from fifo");
                exit(1);
            }
            if (bytesRead == 0) {
                break; // End of data
            }
            buffer[bytesRead] = '\0'; // Null-terminate the string

       int nrvo=nrvoc(buffer);
       printf("String: %s, nr vocale: %d\n", buffer, nrvo);

}
 close(fd);
 exit(0);
}


wait(0);
wait(0);
return(0);
}


------------------------------


PIPE 2 COPII FORK CITIRE STRINGURI 

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#define BUFFER_SIZE 256

int nrvoc(char *str){
  int nrvoc=0;
    for(int i=0;i<strlen(str); i++)
 {
    if(strchr("AEIOUaeiou",str[i])!= NULL)
         nrvoc++;
 }
 return nrvoc;

}

int main(){

int p12[2];

//pipe(p12);

    if (pipe(p12) == -1) {
        perror("Error creating pipe");
        exit(1);
    }

int pid=fork();

 if (pid==-1){
        perror("Eroare fork");

        exit(1);
}

if(pid==0)
{
   //copilul A
close(p12[0]);

  char buffer[BUFFER_SIZE];

 while(1) {

  printf("Introduceti string si exit pt quit: \n");

  fgets(buffer, BUFFER_SIZE, stdin);
  buffer[strcspn(buffer, "\n")] = '\0';
  // Remove newline character

 if (strcmp(buffer, "exit") == 0) {
                close(p12[1]); // Close write end
                exit(0); // Exit the child process
                break;
            }


  write(p12[1],buffer,strlen(buffer)+1);


}
 close(p12[1]);
 exit(0);
}

int p2=fork();

 if (p2==-1){
        perror("Eroare fork");

        exit(1);
}

if (p2==0){ //proces B


 char buffer[BUFFER_SIZE];
 while(1){

 int bytesRead = read(p12[0], buffer, BUFFER_SIZE);
            if (bytesRead == -1) {
                perror("Error reading from fifo");
                exit(1);
            }
            if (bytesRead == 0) {
                break; // End of data
            }
            buffer[bytesRead] = '\0'; // Null-terminate the string

       int nrvo=nrvoc(buffer);
       printf("String: %s, nr vocale: %d\n", buffer, nrvo);

}
 close(p12[0]);
 exit(0);
}

close(p12[0]);
close(p12[1]);
wait(0);
wait(0);
return(0);
}




--------------------


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#define FIFO_NAME "p4fifo"

int main() {
    char initial[100];

    printf("Introduceti sirul initial: ");
    if (fgets(initial, sizeof(initial), stdin) == NULL) {
        fprintf(stderr, "Error reading initial string from stdin\n");
        exit(EXIT_FAILURE);
    }
    // Eliminam newline-ul de la finalul sirului initial
    initial[strcspn(initial, "\n")] = '\0';

    int pid = fork();
    if (pid == -1) {
        perror("Error forking");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Proces copil A
        int fd = open(FIFO_NAME, O_WRONLY);
        if (fd == -1) {
            perror("Error opening FIFO");
            exit(EXIT_FAILURE);
        }

        // Trimitem sirul initial catre procesul copil B
        write(fd, initial, strlen(initial) + 1);

        close(fd);
        exit(EXIT_SUCCESS);
    }

    int p2 = fork();
    if (p2 == -1) {
        perror("Error forking");
        exit(EXIT_FAILURE);
    }

    if (p2 == 0) {
        // Proces copil B
        int fd = open(FIFO_NAME, O_RDONLY);
        if (fd == -1) {
            perror("Error opening FIFO");
            exit(EXIT_FAILURE);
        }

        // Primim sirul initial de la procesul copil A
        char received[100];
        read(fd, received, sizeof(received));

        // Numaram sirurile identice cu sirul initial
        int count = 0;
        char buffer[100];
        printf("Introduceti lista de siruri (terminati introducerea cu 'stop'):\n");
        while (1) {
            if (fgets(buffer, sizeof(buffer), stdin) == NULL || strcmp(buffer, "stop\n") == 0) {
                break;
            }
            char *token = strtok(buffer, " \n");
            while (token != NULL) {
                if (strcmp(token, received) == 0) {
                    count++;
                }
                token = strtok(NULL, " \n");
            }
        }

        printf("Numarul de siruri identice cu %s este: %d\n", received, count);

        close(fd);
        exit(EXIT_SUCCESS);
    }

    wait(NULL);
    wait(NULL);

    return 0;
}

--------------------------

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#define FIFO_NAME "p5fifo"

// Funcție pentru a număra vocalele și cifrele dintr-un șir
void countVowelsAndDigits(char *line, int *vowels, int *digits) {
    *vowels = 0;
    *digits = 0;
    for (int i = 0; line[i] != '\0'; i++) {
        if (line[i] >= '0' && line[i] <= '9') {
            (*digits)++;
        } else if ((line[i] >= 'a' && line[i] <= 'z') || (line[i] >= 'A' && line[i] <= 'Z')) {
            char c = tolower(line[i]);
            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {
                (*vowels)++;
            }
        }
    }
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s filename\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    FILE *file = fopen(argv[1], "r");
    if (!file) {
        perror("Error opening file");
        exit(EXIT_FAILURE);
    }

    int pid = fork();
    if (pid == -1) {
        perror("Error forking");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Proces copil A
        int fd = open(FIFO_NAME, O_WRONLY);
        if (fd == -1) {
            perror("Error opening FIFO");
            exit(EXIT_FAILURE);
        }

        char line[100];
        while (fgets(line, sizeof(line), file) != NULL) {
            // Trimitem fiecare linie catre procesul copil B
            write(fd, line, strlen(line) + 1);
        }

        // Trimitem un mesaj special pentru a semnala sfarsitul transmisiei
        write(fd, "STOP", strlen("STOP") + 1);

        close(fd);
        exit(EXIT_SUCCESS);
    }

    int p2 = fork();
    if (p2 == -1) {
        perror("Error forking");
        exit(EXIT_FAILURE);
    }

    if (p2 == 0) {
        // Proces copil B
        int fd = open(FIFO_NAME, O_RDONLY);
        if (fd == -1) {
            perror("Error opening FIFO");
            exit(EXIT_FAILURE);
        }

        int vowels, digits;
        char line[100];
        while (1) {
            // Primim fiecare linie trimisa de procesul copil A
            read(fd, line, sizeof(line));

            // Verificam daca am primit mesajul special de sfarsit
            if (strcmp(line, "STOP") == 0) {
                break;
            }

            // Numaram vocalele si cifrele din linie
            countVowelsAndDigits(line, &vowels, &digits);
            printf("Linia: %sVocale: %d, Cifre: %d\n", line, vowels, digits);
        }

        close(fd);
        exit(EXIT_SUCCESS);
    }

    wait(NULL);
    wait(NULL);

    return 0;
}

----------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 300

int main(int argc, char *argv[]) {
    FILE *file = fopen(argv[1], "r");
    if (file == NULL) {
        fprintf(stderr, "parametru invalid");
        return 0;
    }

    char marca_max[100];
    char model_max[100];
    int cai_max = 0;
    char line[MAX_LINE_LENGTH];
    while (fgets(line, MAX_LINE_LENGTH, file)) {
        char *marca = strtok(line, ",");
        char *model = strtok(NULL, ",");
        int cai = atoi(strtok(NULL, ","));

        if (cai > cai_max) {
            strcpy(marca_max, marca);
            strcpy(model_max, model);
            cai_max = cai;
        }
    }
    printf("%s %s\n", marca_max, model_max);

    fclose(file);
    return 0;
}



-----------

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#define FIFO_NAME "p4fifo"

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s filename\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    FILE *file = fopen(argv[1], "r");
    if (!file) {
        perror("Error opening file");
        exit(EXIT_FAILURE);
    }

    // Citirea șirului inițial
    char initial[100];
    if (fgets(initial, sizeof(initial), file) == NULL) {
        fprintf(stderr, "Error reading initial string from file\n");
        exit(EXIT_FAILURE);
    }

    // Eliminarea caracterului newline de la finalul șirului inițial
    initial[strcspn(initial, "\n")] = '\0';

    int pid = fork();
    if (pid == -1) {
        perror("Error forking");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Proces copil A
        int fd = open(FIFO_NAME, O_WRONLY);
        if (fd == -1) {
            perror("Error opening FIFO");
            exit(EXIT_FAILURE);
        }

        // Trimitem șirul inițial către procesul copil B
        write(fd, initial, strlen(initial) + 1);

        close(fd);
        exit(EXIT_SUCCESS);
    }

    int p2 = fork();
    if (p2 == -1) {
        perror("Error forking");
        exit(EXIT_FAILURE);
    }

    if (p2 == 0) {
        // Proces copil B
        int fd = open(FIFO_NAME, O_RDONLY);
        if (fd == -1) {
            perror("Error opening FIFO");
            exit(EXIT_FAILURE);
        }

        // Primim șirul inițial de la procesul copil A
        char received[100];
        read(fd, received, sizeof(received));

        // Numărăm șirurile identice cu șirul inițial
        int count = 0;
        char buffer[100];
        while (fgets(buffer, sizeof(buffer), file) != NULL) {
            char *token = strtok(buffer, " \n");
            while (token != NULL) {
                if (strcmp(token, received) == 0) {
                    count++;
                }
                token = strtok(NULL, " \n");
            }
        }

        printf("Numarul de siruri identice cu %s este: %d\n", received, count);

        close(fd);
        exit(EXIT_SUCCESS);
    }

    wait(NULL);
    wait(NULL);

    return 0;
}







----------------------------------------
rezolva cu fifo

paramertru 

nr N sir de numere
5     12 15 55 67 51 10

copil parinte


parintele trimite la copil si nr N si lista de numere

iar copilul da read si printeaza mesaj daca lista de numere are in compozitie cifra N

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// Function to check if digit N is present in a number
int digit_present(int number, int N) {
    while (number > 0) {
        if (number % 10 == N) {
            return 1; // Return 1 if N is found in the number
        }
        number /= 10;
    }
    return 0; // Return 0 if N is not found in the number
}

int main() {
    // Create the FIFO pipe
    mkfifo("p1fifo", 0666);

    int pid = fork();

    if (pid == -1) {
        perror("Error forking");
        exit(1);
    }

    if (pid == 0) {
        // Child process
        int fd = open("p1fifo", O_RDONLY);
        if (fd == -1) {
            perror("Error opening FIFO in child");
            exit(1);
        }

        int N;
        read(fd, &N, sizeof(int)); // Read N from FIFO
        int num;
        printf("Numbers containing %d:\n", N);
        while (read(fd, &num, sizeof(int)) > 0) {
            if (num == -1) {
                break; // Exit loop if -1 is read
            }
            if (digit_present(num, N)) {
                printf("%d\n", num); // Print the number if N is found
            }
        }
        close(fd);
        exit(0);
    } else {
        // Parent process
        int fd = open("p1fifo", O_WRONLY);
        if (fd == -1) {
            perror("Error opening FIFO in parent");
            exit(1);
        }

        int N;
        printf("Enter a digit (N): ");
        scanf("%d", &N);
        write(fd, &N, sizeof(int)); // Write N to FIFO

        printf("Enter a list of numbers (-1 to finish):\n");
        int num;
        while (1) {
            scanf("%d", &num);
            write(fd, &num, sizeof(int)); // Write numbers to FIFO
            if (num == -1) {
                break; // Exit loop if -1 is entered
            }
        }
        close(fd);
    }

    return 0;
}



-------------------------------------

rezolva cu fifo

paramertru 

nr N sir stringuri
5     aaaaa bvcc ana are meree


copil parinte


parintele trimite la copil si nr N si lista de stringuri

iar copilul da read si printeaza mesaj daca ficare cuvant are un nr de vocale = N



#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#define MAX_LENGTH 100

// Function to count the number of vowels in a string
int count_vowels(const char *str) {
    int count = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        if (strchr("aeiouAEIOU", str[i])) {
            count++;
        }
    }
    return count;
}

int main() {
    // Create the FIFO pipe
    mkfifo("p1fifo", 0666);

    int pid = fork();

    if (pid == -1) {
        perror("Error forking");
        exit(1);
    }

    if (pid == 0) {
        // Child process
        int fd = open("p1fifo", O_RDONLY);
        if (fd == -1) {
            perror("Error opening FIFO in child");
            exit(1);
        }

        int N;
        read(fd, &N, sizeof(int)); // Read N from FIFO
        char word[MAX_LENGTH];
        printf("Words with %d vowels:\n", N);
        while (read(fd, word, MAX_LENGTH) > 0) {
            if (strlen(word) == 0) {
                break; // Exit loop if an empty string is read
            }
            if (count_vowels(word) == N) {
                printf("%s\n", word); // Print the word if it has N vowels
            }
        }
        close(fd);
        exit(0);
    } else {
        // Parent process
        int fd = open("p1fifo", O_WRONLY);
        if (fd == -1) {
            perror("Error opening FIFO in parent");
            exit(1);
        }

        int N;
        printf("Enter a number (N): ");
        scanf("%d", &N);
        write(fd, &N, sizeof(int)); // Write N to FIFO

        printf("Enter a list of words (empty word to finish):\n");
        char word[MAX_LENGTH];
        while (1) {
            getchar(); // Consume newline character left in buffer
            fgets(word, MAX_LENGTH, stdin); // Read a word from stdin
            word[strcspn(word, "\n")] = '\0'; // Remove newline character if present
            write(fd, word, MAX_LENGTH); // Write the word to FIFO
            if (strlen(word) == 0) {
                break; // Exit loop if an empty string is entered
            }
        }
        close(fd);
    }

    return 0;
}

-------------------------------------------




---------------------------------------------------------------
1

rezolva cu fifo
copil parinte
parintele trimite cate o linie din fisier la copil



problema
fisier
miere
pere 
banane
ana
maria


sorteaza descrescator dupa numarul de litere
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <string.h>

#define FIFO_FILE "myfifo"
#define MAX_LINE_LENGTH 100

// Funcție pentru a sorta descrescător după lungimea cuvintelor
int compare(const void *a, const void *b) {
    return strlen(*(const char **)b) - strlen(*(const char **)a);
}

int main() {
    int fd;
    pid_t pid;
    char line[MAX_LINE_LENGTH];

    // Creăm FIFO
    mkfifo(FIFO_FILE, 0666);

    // Creăm un proces copil
    pid = fork();

    if (pid == -1) {
        perror("Error forking");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) { // Procesul copil
        // Deschidem FIFO pentru citire
        fd = open(FIFO_FILE, O_RDONLY);

        if (fd == -1) {
            perror("Error opening FIFO for reading");
            exit(EXIT_FAILURE);
        }

        char lines[1000][MAX_LINE_LENGTH];
        int line_count = 0;

        // Citim liniile din FIFO
        while (read(fd, line, MAX_LINE_LENGTH) > 0) {
            strcpy(lines[line_count++], line);
        }

        // Sortăm liniile descrescător după lungimea cuvintelor
        qsort(lines, line_count, sizeof(lines[0]), compare);

        // Închidem FIFO pentru citire
        close(fd);

        // Deschidem FIFO pentru scriere
        fd = open(FIFO_FILE, O_WRONLY);

        if (fd == -1) {
            perror("Error opening FIFO for writing");
            exit(EXIT_FAILURE);
        }

        // Trimitem liniile sortate înapoi către procesul părinte
        for (int i = 0; i < line_count; i++) {
            write(fd, lines[i], strlen(lines[i]) + 1);
        }

        // Închidem FIFO pentru scriere
        close(fd);

        exit(EXIT_SUCCESS);
    } else { // Procesul părinte
        // Deschidem FIFO pentru scriere
        fd = open(FIFO_FILE, O_WRONLY);

        if (fd == -1) {
            perror("Error opening FIFO for writing");
            exit(EXIT_FAILURE);
        }

        // Deschidem fișierul pentru citire
        FILE *input_file = fopen("input.txt", "r");

        if (input_file == NULL) {
            perror("Error opening input file");
            exit(EXIT_FAILURE);
        }

        // Citim fiecare linie din fișier și o trimitem prin FIFO la procesul copil
        while (fgets(line, sizeof(line), input_file) != NULL) {
            write(fd, line, strlen(line) + 1);
        }

        // Închidem fișierul și FIFO
        fclose(input_file);
        close(fd);

        // Așteptăm terminarea procesului copil
        wait(NULL);
    }

    // Ștergem FIFO
    unlink(FIFO_FILE);

    return 0;
}



---------------------------------------------------------------
2
rezolva cu fifo



folositi strotk

nume varsta salariu

avem fisierul
ana,17,1000
mihai,20,1500
camren,24,9999
ion,19,4500
mirel,34,2355



cu fifo

parinte copil


parintele citeste cate o linie si o trimite copilului

copilil analizeaza linia si sortreaza descrescator dupa salariu

  
    FILE* fisier=fopen(argv[2],"r");
    if(!fisier){
        perror("eroare la deschirerea fisierului");
        return 2;
    }


foloseste pt char sintaxa asa

 int nlen=0;
        read(piperecv[0],&nlen,sizeof(int));             //primim lungimea numelui
        char *nume=(char*)malloc((nlen+1)*sizeof(char)); //alocam memorie pt nume
        read(piperecv[0],nume,nlen);                     //citim efectiv numele (string)
        nume[nlen]='\0';                                 //ne asiguram ca stringul se termina cu null





#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <string.h>

#define FIFO_FILE "myfifo"

// Structură pentru informațiile despre angajați
typedef struct {
    char nume[100];
    int varsta;
    int salariu;
} Angajat;

// Funcție pentru a sorta descrescător după salariu
int compare(const void *a, const void *b) {
    return ((Angajat *)b)->salariu - ((Angajat *)a)->salariu;
}

int main(int argc, char *argv[]) {
    int fd;
    pid_t pid;
    char line[256];

    // Creăm FIFO
    mkfifo(FIFO_FILE, 0666);

    // Creăm un proces copil
    pid = fork();

    if (pid == -1) {
        perror("Error forking");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) { // Procesul copil
        // Deschidem FIFO pentru citire
        fd = open(FIFO_FILE, O_RDONLY);

        if (fd == -1) {
            perror("Error opening FIFO for reading");
            exit(EXIT_FAILURE);
        }

        Angajat angajati[100];
        int count = 0;

        // Citim liniile din FIFO și le analizăm
        while (read(fd, line, sizeof(line)) > 0) {
            char *token = strtok(line, ",");
            strcpy(angajati[count].nume, token);
            token = strtok(NULL, ",");
            angajati[count].varsta = atoi(token);
            token = strtok(NULL, ",");
            angajati[count].salariu = atoi(token);
            count++;
        }

        // Sortăm angajații descrescător după salariu
        qsort(angajati, count, sizeof(Angajat), compare);

        // Închidem FIFO pentru citire
        close(fd);

        // Deschidem FIFO pentru scriere
        fd = open(FIFO_FILE, O_WRONLY);

        if (fd == -1) {
            perror("Error opening FIFO for writing");
            exit(EXIT_FAILURE);
        }

        // Trimitem înapoi angajații sortați
        for (int i = 0; i < count; i++) {
            write(fd, &angajati[i], sizeof(Angajat));
        }

        // Închidem FIFO pentru scriere
        close(fd);

        exit(EXIT_SUCCESS);
    } else { // Procesul părinte
        // Deschidem FIFO pentru scriere
        fd = open(FIFO_FILE, O_WRONLY);

        if (fd == -1) {
            perror("Error opening FIFO for writing");
            exit(EXIT_FAILURE);
        }

        // Deschidem fișierul pentru citire
        FILE *input_file = fopen(argv[1], "r");

        if (input_file == NULL) {
            perror("Error opening input file");
            exit(EXIT_FAILURE);
        }

        // Citim fiecare linie din fișier și o trimitem prin FIFO la procesul copil
        while (fgets(line, sizeof(line), input_file) != NULL) {
            write(fd, line, strlen(line) + 1);
        }

        // Închidem fișierul și FIFO
        fclose(input_file);
        close(fd);

        // Așteptăm terminarea procesului copil
        wait(NULL);
    }

    // Ștergem FIFO
    unlink(FIFO_FILE);

    return 0;
}


------------------------



------------------------------------------------------
1,ana,1920
sscanf(line, "%d,%[^,],%d", &id, name, &year);


---------
problema simpla cu fifo     SI FILE TXT
 

banane,10
capsune,8
cirese,20

copilul ne afiseaza cel mai scump fruct

 #include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

#define FIFO_FILE "fruits_fifo"
#define MAX_LINE_LENGTH 100

int main() {
    // Cream FIFO
    mkfifo(FIFO_FILE, 0666);

    pid_t pid = fork();

    if (pid < 0) {
        perror("Error forking");
        exit(EXIT_FAILURE);
    } else if (pid == 0) { // Suntem în copil
        // Deschidem FIFO pentru a citi
        int fifo_fd = open(FIFO_FILE, O_RDONLY);
        if (fifo_fd < 0) {
            perror("Error opening FIFO for reading");
            exit(EXIT_FAILURE);
        }

        char fruit[50];
        int price, max_price = 0;

        // Citim fiecare pereche de fruct și preț
        while (read(fifo_fd, fruit, sizeof(fruit)) > 0 && read(fifo_fd, &price, sizeof(int)) > 0) {
            if (price > max_price) {
                max_price = price;
            }
        }

        // Afisam fructul cel mai scump
        printf("The most expensive fruit is: %s\n", fruit);

        // Închidem FIFO
        close(fifo_fd);
    } else { // Suntem în părinte
        // Deschidem fișierul pentru citire
        FILE *file = fopen("fr.txt", "r");
        if (!file) {
            perror("Error opening file for reading");
            exit(EXIT_FAILURE);
        }

        // Deschidem FIFO pentru a scrie
        int fifo_fd = open(FIFO_FILE, O_WRONLY);
        if (fifo_fd < 0) {
            perror("Error opening FIFO for writing");
            exit(EXIT_FAILURE);
        }

        char line[MAX_LINE_LENGTH];
        char fruit[50];
        int price;

        // Citim fiecare linie din fișier și trimitem perechile de fruct și preț prin FIFO
        while (fgets(line, sizeof(line), file) != NULL) {
            sscanf(line, "%[^,],%d", fruit, &price);
            write(fifo_fd, fruit, sizeof(fruit));
            write(fifo_fd, &price, sizeof(int));
        }

///sauuuu
while (fgets(line, sizeof(line), file) != NULL) {
    char *token = strtok(line, ",");
    while (token != NULL) {
        // Trimitem fiecare cuvant (token) prin FIFO
        write(fifo_fd, token, strlen(token) + 1); // Adaugăm 1 pentru caracterul null terminator
        token = strtok(NULL, ","); // Continuăm cu următorul cuvânt
    }
}

        // Închidem FIFO
        close(fifo_fd);

        // Închidem fișierul
        fclose(file);
    }

    // Înlăturăm FIFO
    unlink(FIFO_FILE);

    return 0;
}



=============================================


LAB 13 TEAMS PROBLEME RECAPITULATIVEEEEEE


1.

Scrieti un program C care creeaza 2 procese copil, C1 si C2. 
Procesul C1 citeste de la tastatura stringuri de maxim 20 
de caractere pana se da stringul stop si le trimite catre 
C2 prin pipe, care calculeaza numarul de vocale si apoi 
trimite inapoi tot prin pipe acest numar. C1 afiseaza pentru 
fiecare string numarul de vocale primit de la C1.

//Scrieti un program C care creeaza 2 procese copil, C1 si C2.
//Procesul C1 citeste de la tastatura stringuri de maxim 20
//de caractere pana se da stringul stop si le trimite catre
//C2 prin pipe, care calculeaza numarul de vocale si apoi
//trimite inapoi tot prin pipe acest numar. C1 afiseaza pentru
//fiecare string numarul de vocale primit de la C1.


#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>

#define MAX_LENGTH 20

int nrvocale(char *sir) //sir[]
{
  int nrvoc=0;
  //char vocale[]="aeiouAEIOU";
  for(int i=0;i<strlen(sir); i++)
 {
    if(strchr("AEIOUaeiou",sir[i])!= NULL)
         nrvoc++;
 }
return nrvoc;

}


int main(int argc, char* argv[])
{

int c1c2[2]; // 0 read, 1 write
int c2c1[2]; //comunica copii intre ei

pipe(c1c2);
pipe(c2c1);


    //if (pipe(c1c2) == -1 || pipe(c2c1) == -1) {
      //  perror("eroare pipe");
        //exit(EXIT_FAILURE);
   // }


// + VALIDARIIIIIIIII PIPE
// + VALIDARI FORK

int pid1=fork();

// validare pid1
 if (pid1 < 0) {
        perror("fork");
        exit(EXIT_FAILURE);
    }



if(pid1 == 0)
{
   // suntem in primul copil
    // C1 citeste stringuri de max 20 caractere
  close(c1c2[0]);
  close(c2c1[1]);

  char input[MAX_LENGTH+1];
  int nrvocale;

  while(1)
{
   printf("Introduceti un string\n");
   //scanf("%19s", stringuri);


           fgets(input,MAX_LENGTH+1, stdin);
           input[strcspn(input, "\n")] = 0;

            if (strcmp(input, "stop") == 0) {
                break;
            }



  //write(c1c2[1],stringuri,strlen(stringuri)+1); //am trimis stringurile catre procesul 2


  write(c1c2[1],input,strlen(input)+1);
  read(c2c1[0],&nrvocale, sizeof(int)); //primil de la proc 2 nr de vocale din string

  if(nrvocale==-1) {break;}

  printf("Numarul de vocale in %s este: %d\n",input, nrvocale);

}
  close(c1c2[1]);
  close(c2c1[0]);
  exit(0);
}


// inapoi in parinte

//facem al doilea copil

int pid2=fork();

// validare pid2

if(pid2==0) {

 close(c1c2[1]);
 close(c2c1[0]);

 char stringuri[MAX_LENGTH+1];
 int nrvocc=0;
 while(1){
  //int i=0;
  //char ch;

  //while(read(c1c2[0],&ch, sizeof(char)) > 0 && ch!='\0')

//{
  // stringuri[i++]=ch;
 //if (i >= 20) break;
//}

//stringuri[i] = '\0';

  //if(strcmp(stringuri,"stop") ==0) {
    //    int final=-1;
      //  write(c2c1[1],&final, sizeof(int));
        //break;
//}
// else {
  //  int nrvocc=nrvocale(stringuri);
    //write(c2c1[i],&nrvocc,sizeof(int));

   //}
//
            int n = read(c1c2[0], stringuri, sizeof(stringuri));
            if (n <= 0) {
                break;
            }

            nrvocc = nrvocale(stringuri);
            write(c2c1[1], &nrvocc, sizeof(int));


}
close(c2c1[1]);
close(c1c2[0]);
exit(0);
}


close(c1c2[0]);
close(c1c2[1]);
close(c2c1[0]);
close(c2c1[1]);
wait(0); //WAIT NULL
wait(0);
return 0;
}



pb 4 + proces



#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 300

char marca_max[100];
char model_max[100];
int cai_max = 0;

int main(int argc, char *argv[]) {
    FILE *file = fopen(argv[1], "r");
    if (file == NULL) {
        fprintf(stderr, "parametru invalid");
        return 0;
    }
    char line[MAX_LINE_LENGTH];
    while (fgets(line, MAX_LINE_LENGTH, file)) {
        pid_t pid = fork();
        if(pid < 0) { // eroare
                fprintf(stderr, "eroare la fork()");
        }
        else if(pid == 0) { // copil
                char *marca = strtok(line, ",");
                char *model = strtok(NULL, ",");
                int cai = atoi(strtok(NULL, ","));
                if (cai > cai_max) {
                        strcpy(marca_max, marca);
                        strcpy(model_max, model);
                        cai_max = cai;
                }
        }
        else { // parinte
                int status;
                wait(&status);
                exit(0);
        }
    }
    printf("%s %s\n", marca_max, model_max);

    fclose(file);
    return 0;
}





pb 4 + pipe

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>

#define MAX_LINE_LENGTH 300

char model_max[100];
char marca_max[100];
int cai_max;

int main(int argc, char *argv[]) {
    FILE *file = fopen(argv[1], "r");
    if (file == NULL) {
        fprintf(stderr, "parametru invalid");
        return 0;
    }
    char line[MAX_LINE_LENGTH];
    while (fgets(line, MAX_LINE_LENGTH, file)) {
    	int fdp[2];
    	if (pipe(fdp) == -1) {
        	fprintf(stderr, "eroare la pipe()");
        	return 1;
    	}
    	pid_t pid = fork();
    	if(pid < 0) { // eroare
    		fprintf(stderr, "eroare la fork()");
    		return 1;
    	}
    	else if(pid == 0) { // copil
    		close(fdp[0]);
    		char *marca = strtok(line, ",");
        	char *model = strtok(NULL, ",");
        	int cai = atoi(strtok(NULL, ","));
    		int n = strlen(marca);
        	write(fdp[1],&n,sizeof(int));
        	int m = strlen(model);
        	write(fdp[1],&m,sizeof(int));
        	write(fdp[1],marca,n*sizeof(char));
        	write(fdp[1],model,m*sizeof(char));
                write(fdp[1],&cai,sizeof(int));
        	close(fdp[1]);
        	exit(0);
        }

        else { // parinte
        	close(fdp[1]);
    		int n,m;
    		read(fdp[0],&n,sizeof(int));
    		read(fdp[0],&m,sizeof(int));
    		char *marca = (char*)malloc((n+1)*sizeof(char));
    		char *model = (char*)malloc((m+1)*sizeof(char));
    		read(fdp[0],marca,n);
    		marca[n] = '\0';
    		read(fdp[0],model,m);
    		model[m] = '\0';
    		int cai;
    		read(fdp[0],&cai,sizeof(int));
    		close(fdp[0]);
    		if(cai > cai_max) {
    			cai_max = cai;
    			strcpy(marca_max, marca);
    			strcpy(model_max, model);
    		}
        }
    }
    int status;
    while(wait(&status) > 0);
    printf("%s %s\n", marca_max, model_max);
    fclose(file);
    return 0;

}



pb4 + fifo


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <fcntl.h>

#define MAX_LINE_LENGTH 300
#define NUME_FIFO "lab11.fifo"

char model_max[100];
char marca_max[100];
int cai_max;

int main(int argc, char *argv[]) {
    FILE *file = fopen(argv[1], "r");
    if (file == NULL) {
        fprintf(stderr, "parametru invalid");
        return 0;
    }
    char line[MAX_LINE_LENGTH];
    while (fgets(line, MAX_LINE_LENGTH, file)) {
    	int status = mkfifo(NUME_FIFO,0666);
    	if(status == -1) {
    		fprintf(stderr, "eroare la mkfifo()");
    	}
    	pid_t pid = fork();
    	if(pid < 0) { // eroare
    		fprintf(stderr, "eroare la fork()");
    		return 1;
    	}
    	else if(pid == 0) { // copil
    		int fd = open(NUME_FIFO, O_WRONLY);
    		char *marca = strtok(line, ",");
        	char *model = strtok(NULL, ",");
        	int cai = atoi(strtok(NULL, ","));
    		int n = strlen(marca);
        	write(fd,&n,sizeof(int));
        	int m = strlen(model);
        	write(fd,&m,sizeof(int));
        	write(fd,marca,n*sizeof(char));
        	write(fd,model,m*sizeof(char));
                write(fd,&cai,sizeof(int));
                close(fd);
                fclose(file);
        	exit(0);
        }

        else { // parinte
        	int fd = open(NUME_FIFO, O_RDONLY);
    		int n,m;
    		read(fd,&n,sizeof(int));
    		read(fd,&m,sizeof(int));
    		char *marca = (char*)malloc((n+1)*sizeof(char));
    		char *model = (char*)malloc((m+1)*sizeof(char));
    		read(fd,marca,n);
    		marca[n] = '\0';
    		read(fd,model,m);
    		model[m] = '\0';
    		int cai;
    		read(fd,&cai,sizeof(int));
    		if(cai > cai_max) {
    			cai_max = cai;
    			strcpy(marca_max, marca);
    			strcpy(model_max, model);
    		}
        }
    }
    int status;
    while(wait(&status) > 0);
    printf("%s %s\n", marca_max, model_max);
    unlink(NUME_FIFO);
    return 0;

}


ex1.c

#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h> //pt exit



int main(){
  //  char string[]="fulga are lapte";
    int fdpipe[2]; //vector cu 2 elemente, file descriptor pipe   write--------read  pipe
// la 0 capat citim si la cap 1 scriem conventie
  // pipe e unidirectional w--> read   pipe fara nume
   pipe(fdpipe); //cream pipe

//verificare status
 int pid=fork(); //cream un proces
 if(pid==0)
{
        //copil
        char string[16]="fulga are lapte";
        close(fdpipe[0]); //inchidem pipe ca nu are treaba cu citirea el doar scrie
//int are 4 bytes
        int n=strlen(string);       //nu sizeof
        write(fdpipe[1],&n,sizeof(n)); //sizeof int sau sizeof n
        write(fdpipe[1],string,n);   //string e vecgtor si vectorul se comporta ca un vector
//si aici n u i mai dam adresa
        close(fdpipe[1]);
        exit(0); //inchidem procesul copi;
}

//doar parinte
close(fdpipe[1]);
//inainte sa citim stringul sa primim stringul ii luam lungimea
int nrec=0; //nrecieve
read(fdpipe[0],&nrec,sizeof(int));    //vream sa punem ceea ce citeste in nrec
char* ps=(char*)malloc(sizeof(char)*nrec+1); //dimensiunea*nhr de elemente+1 null
    //merge si ceva asa char ps[nrec] dae fiind pe stiva nu aceptac aloc dinamica/variabila >
read(fdpipe[0],ps,nrec);
ps[nrec]='\0'; //indexarea e de la 0, nu+1
printf("am primit: %s\n",ps);
return 0;

//aici parintele nu asteapta nu avem wait pt ca sincronizarea e deja facuta la read
}





===========================================



PIPE PRODUS 1 NUMERE
EX REZOLVAT PROFAAAAAAAAAAA


// un proces creeaza un proces copil caruia ii trimite 2 numere prin pipe
//copilul trimite inapoi produsul lor




#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>


// un proces creeaza un proces copil caruia ii trimite 2 numere prin pipe
//copilul trimite inapoi produsul lor

int main(){

 int p2c[2]; //parinte to copil
 int c2p[2]; //copil to parinte
//c2p[0], c2[1]
//c2p[0] e fdescr care citeste din pipe
//c2p[1] e fdescr care scrie pe pipe


 pipe(p2c); //se creeaza un pipe unidirectional du 2 file descriptors
 pipe(c2p);

 int pid=fork();
 if (pid==0)
{
  //proces copil
  int n1,n2;
  close(p2c[1]); // inchidem capatul de scriere ca nu scriem pe el
  close(c2p[0]); // inch cap de citire pt ca nu citim din el

  read(p2c[0], &n1, sizeof(int)); // citim nr din procesul parinte
  read(p2c[0], &n2, sizeof(int));

  printf("copilul a primit numerele %d si %d \n", n1,n2);

  n1=n1*n2;
  write(c2p[1], &n1, sizeof(int)); // copilul scrie produsul inapoi in procesul parinte
  close(p2c[0]); // inchidem ce a ramas
  close(c2p[1]);

  exit(0);

}


//procesul parinte
close(p2c[0]); //nenecesare parintele inchide capatul de citire pt ca nu citeste din el
close(c2p[1]);

int a=5,b=7,p;
write(p2c[1], &a, sizeof(int)); // scriem [1] numerele catre procesul copil, pe care copilul le citeste
write(p2c[1], &b, sizeof(int));

read(c2p[0], &p, sizeof(int)); // parintele citeste rezultatul din copil

printf("Parintele a primit produsul: %d \n", p);

close(p2c[1]);
close(c2p[0]);

wait(0); // asteapta dupa copil sa termine

return 0;
}

----------------------------------------------

EX 2 REZOLVAT PROFA PIPE   eliminare prin pipe ultim caracter string


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <string.h>

// un proces creeaza un proces copil caruia ii trimite un string prin pipe
//copilul trimite inapoi stringul fara ultima litera

int main(){

 int p2c[2]; //parinte to copil
 int c2p[2]; //copil to parinte
 pipe(p2c);
 pipe(c2p);

 int pid=fork();
 if (pid==0){
  //proces copil
  char cuv[30];
  int len;

  close(p2c[1]);
  close(c2p[0]);

  read(p2c[0], &len, sizeof(int));  // la stringuri intai citim lungimea
  read(p2c[0], cuv, sizeof(char)*len); // apoi citim stringul efectiv

  printf("copilul a primit numerele stringul %s \n", cuv);

  len--; //scadem lungimea cuvantului
  cuv[len-1]='\0';  //stergem ultima litera

  write(c2p[1], &len, sizeof(int)); // scriem intai lungimea
  write(c2p[1], cuv, sizeof(char)*len); // apoi scriem stringul efectiv


  close(p2c[0]);
  close(c2p[1]);

  exit(0);

}


//procesul parinte
close(p2c[0]);
close(c2p[1]);


printf("Introduceti cuv/propozitia: ");

char cuv[30];
scanf("%s", cuv);
int len=strlen(cuv)+1;

write(p2c[1], &len, sizeof(int));
write(p2c[1], cuv, sizeof(char)*(len));

read(c2p[0], &len, sizeof(int));
read(c2p[0], cuv, sizeof(char)*(len));


printf("Parintele a primit cuvantul: %s \n", cuv);

close(p2c[1]);
close(c2p[0]);

wait(0);

return 0;
}




---------------------------------------------------

suma 2 nr prin pipe

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>

// un proces creeaza un proces copil caruia ii trimite 2 nr prin pipe
//copilul trimite inapoi suma celor 2 nr

int main(){

 int p2c[2]; //parinte to copil
 int c2p[2]; //copil to parinte

 int a,b,suma;

 pipe(p2c);
 pipe(c2p);

 int pid=fork();

if (pid == -1) {
        perror("Fork failed");
        exit(EXIT_FAILURE);
    }



 if (pid==0){

 //proces copil
  close(p2c[1]); // Close write end in child
  close(c2p[0]); // Close read end in child

 read(p2c[0], &a, sizeof(int));
 read(p2c[0], &b, sizeof(int));

// de fapt cica inainte de read
// dupa citire aici ar fi bine sa inchidem direct pipe ends
// sa inchidem p2c[1] si c2p[0]

 suma=a+b;

write(c2p[1], &suma, sizeof(int));

close(p2c[0]);
//close(p2c[1]);
//close(c2p[0]);
close(c2p[1]);

exit(0);
}


// procesul parinte


   close(p2c[0]); // Close read end in parent
    close(c2p[1]); // Close write end in parent

a=3,b=7;

write(p2c[1], &a, sizeof(int));
write(p2c[1], &b, sizeof(int));

// fix dupa write trebuie inchis p2c[0] si c2p[1]


read(c2p[0], &suma, sizeof(int));

printf("%d + %d = %d\n",a,b,suma);


//close(p2c[0]);
close(p2c[1]);
close(c2p[0]);
//close(c2p[1]);

wait(0);


return 0;
}

FIFO = pipe cu nume

-------------------------------------------------------------------------

SUMA A 2 NR PRIN FIFO

Comunicare între procese: Parintele trimite două numere catre procesul copil prin FiFo-ul "fp2c". Copilul citește aceste numere și calculează suma lor. Apoi, copilul trimite rezultatul înapoi procesului parinte prin FiFo-ul "fc2p".

Accesarea FiFo-urilor prin descriptori de fișiere: FiFo-urile sunt accesate prin intermediul descriptorilor de fișiere returnați de funcția open.
Ștergerea FiFo-urilor: La sfârșitul programului, FiFo-urile sunt șterse din sistemul de fișiere utilizând funcția unlink.

#include <stdio.h>

#include <sys/types.h>

#include <unistd.h>

#include <stdlib.h>

#include <sys/wait.h>

#include <sys/stat.h>

#include <fcntl.h>

//Parintele trimite 2 numere catre procesul copil.
//Procesul copil calculeaza suma numerelor si o trimite catre procesul parinte prin FIFO.


int main() {

   mkfifo("fp2c",0666);
   mkfifo("fc2p",0666);

   int pid=fork();

   if (pid==-1){
        perror("Eroare fork");

        exit(1);
}

   if (pid==0){
    int p2c = open("fp2c",O_RDONLY); // ca copilul sa citeasca de la parinte
    int c2p = open("fc2p",O_WRONLY); // ca copilul sa scrie catre parinte

    int n1,n2;

    read(p2c,&n1, sizeof(int)); // citire din parinte
    read(p2c,&n2, sizeof(int));

    close(p2c);
    printf("Copil: Am primit numerele %d si %d \n", n1, n2);

    n1+=n2;
    write(c2p, &n1, sizeof(int)); // copil write catre parinte
    close(c2p);

    exit(0);

}

//procesul parinte
int a=10,b=20;
int p2c=open("fp2c", O_WRONLY); // ca sa facem write catre copil
int c2p=open("fc2p", O_RDONLY); // ca parintele sa faca read din copil



write(p2c,&a, sizeof(int)); //parintele trimite nr 1

write(p2c, &b, sizeof(int)); // si nr 2

close(p2c);

read(c2p, &a, sizeof(int)); // parintele citeste rez suma din copil

printf("Parinte: Suma numerelor este %d \n ", a);

close(c2p);

wait(0);

unlink("fp2c");
unlink("fc2p");

return 0;
}






-------------
LAB 10 BOTA
 
Dati maxim 30 de caractere: ana are mere si pere
[P2] Am citit ana are mere si pere
[P3] Am citit ana are mere si pere



#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

#define MAX_SIZE 50

int main(int argc, char *argv[])
{
        // creez pipe-urile
        int pd12[2];  // comunicare parinte - copil 1
        if (pipe(pd12) < 0)
        {
                perror("pipe()");
                exit(1);
        }

        int pd13[2];
        if (pipe(pd13) < 0)  // comunicare parinte - copil 2
        {
                perror("pipe()");
                exit(1);
        }

        // creez primul copil (proces 2)
        int p2 = fork();
        if (p2 == -1)
        {
                perror("fork()");
                exit(1);
        }

        // in procesul 2
        if (p2 == 0)
        {
                close(pd12[1]);
                close(pd13[1]);

                char input[MAX_SIZE];
                read(pd12[0], input, MAX_SIZE);
                printf("[P2] Am citit %s\n", input);

                close(pd12[0]);
                close(pd13[0]);
                exit(0);
        }

        // creez al doilea copil (proces 3)
        int p3 = fork();
        if (p3 == -1)
        {
                perror("fork()");
                exit(1);
        }

        // in procesul 2
        if (p3 == 0)
        {
                close(pd12[1]);
                close(pd13[1]);

                char input[MAX_SIZE];
                read(pd13[0], input, MAX_SIZE);
                printf("[P3] Am citit %s\n", input);

                close(pd12[0]);
                close(pd13[0]);
                exit(0);
        }

        // in parinte

        close(pd12[0]);
        close(pd13[0]);

        // citeste o linie de maxim 30 de caractere
        char input[MAX_SIZE];
        printf("Dati maxim 30 de caractere: ");
        fgets(input, MAX_SIZE, stdin);

        // scriu catre procesul 2
        write(pd12[1], input, MAX_SIZE);

        // scriu catre procesul 3
        write(pd13[1], input, MAX_SIZE);

        close(pd12[1]);
        close(pd13[1]);

        wait(NULL);
        wait(NULL);

        return 0;
}

===========================================
 


-------------------------------------------------------------------------

 

P1: 

#include <stdio.h> 

#include <stdlib.h> 

#include <string.h> 

#include <unistd.h> 

#include <fcntl.h> 

#include <sys/stat.h> 

  

#define FIFO1 "fifo1david321" 

#define FIFO2 "fifo2david321" 

#define MAX_LEN 1024 

  

int main() { 

 

    char input[MAX_LEN]; 

    printf("Introduceti un sir de numere intregi separate prin spatii: "); 

    fgets(input, MAX_LEN, stdin); 

    input[strcspn(input, "\n")] = '\0'; // Elimină newline-ul de la final 

  

    // Trimite șirul de numere către P2 

    int fd1 = open(FIFO1, O_WRONLY); 

    if (fd1 == -1) { 

        perror("open FIFO1 for writing"); 

        exit(EXIT_FAILURE); 

    } 

    write(fd1, input, strlen(input) + 1); 

    close(fd1); 

  

    // Primește produsul de la P2 

    char product_str[MAX_LEN]; 

    int fd2 = open(FIFO2, O_RDONLY); 

    if (fd2 == -1) { 

        perror("open FIFO2 for reading"); 

        exit(EXIT_FAILURE); 

    } 

    read(fd2, product_str, MAX_LEN); 

    close(fd2); 

  

    printf("Produsul elementelor din sir este: %s\n", product_str); 

  

    return 0; 

} 

 

P2: 

#include <stdio.h> 

#include <stdlib.h> 

#include <string.h> 

#include <unistd.h> 

#include <fcntl.h> 

#include <sys/stat.h> 

  

#define FIFO1 "fifo1david321" 

#define FIFO2 "fifo2david321" 

#define MAX_LEN 1024 

  

int main() { 

    // Primește șirul de numere de la P1 

    char input[MAX_LEN]; 

    int fd1 = open(FIFO1, O_RDONLY); 

    if (fd1 == -1) { 

        perror("open FIFO1 for reading"); 

        exit(EXIT_FAILURE); 

    } 

    read(fd1, input, MAX_LEN); 

    close(fd1); 

  

    // Calculează produsul numerelor 

    char *token = strtok(input, " "); 

    long long product = 1; 

    while (token != NULL) { 

        product *= atoi(token); 

        token = strtok(NULL, " "); 

    } 

  

    // Trimite rezultatul înapoi la P1 

    char product_str[MAX_LEN]; 

    snprintf(product_str, MAX_LEN, "%lld", product); 

    int fd2 = open(FIFO2, O_WRONLY); 

    if (fd2 == -1) { 

        perror("open FIFO2 for writing"); 

        exit(EXIT_FAILURE); 

    } 

    write(fd2, product_str, strlen(product_str) + 1); 

    close(fd2); 

  

    return 0; 

} 


 







------------------
FULGA STUFF LABS


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <string.h>

int main()
{
   int fdpipe[2];
   char string[30]="ana are mere";

   if (pipe(fdpipe) == -1){
      perror("Pipe failed");
      exit(EXIT_FAILURE);
}

  int pid=fork();
  if(pid == -1) {

   perror("fork failed");
   exit(EXIT_FAILURE);
}

if (pid==0)

{
   close(fdpipe[0]);

   write(fdpipe[1], string, strlen(string)+1);

   close(fdpipe[1]);

  //exit(EXIT_SUCCES);
   exit(0);

}

//parinte

close(fdpipe[1]);

char stringprimit[30];

read(fdpipe[0], stringprimit, sizeof(stringprimit));

printf("Parintele a primit: %s\n", stringprimit);

close(fdpipe[0]);


wait(0); // asteapta dupa copil sa termine


return 0;
}





